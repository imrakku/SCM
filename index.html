<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last-Mile Delivery Optimization - Chandigarh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://d3js.org/d3-delaunay.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heatmap.js@2.0.5/build/heatmap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-heatmap@1.0.0/leaflet-heatmap.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script> <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
            background-color: #f1f5f9; /* slate-100 */
        }
        .nav-active {
            border-bottom-width: 3px;
            border-color: #1d4ed8; /* blue-700 */
            color: #1d4ed8; /* blue-700 */
            font-weight: 700;
        }
        .nav-link:hover {
            color: #2563eb; /* blue-600 */
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        #simulationMap, #clusteringMapViz, #optimizationMapViz, #profileCreationMap { 
            height: 500px;
            min-height: 400px;
            border-radius: 0.75rem; /* rounded-xl */
            background-color: #e2e8f0; /* slate-200 */
            border: 1px solid #cbd5e1; /* slate-300 */
        }
         #profileCreationMap {
            height: 300px; /* Smaller map for profile creation */
            min-height: 250px;
        }
        .leaflet-popup-content-wrapper {
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem; /* rounded-lg */
            font-weight: 600;
            transition: background-color 0.2s, opacity 0.2s, transform 0.15s, box-shadow 0.15s;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            line-height: 1.25;
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px -3px rgba(0,0,0,0.15);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background-color: #2563eb; /* blue-600 */
            color: white;
            box-shadow: 0 4px 8px -2px rgba(37, 99, 235, 0.4);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #1d4ed8; /* blue-700 */
        }
        .btn-secondary {
            background-color: #475569; /* slate-600 */
            color: white;
            box-shadow: 0 4px 8px -2px rgba(71, 85, 105, 0.3);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #334155; /* slate-700 */
        }
        .btn-danger {
            background-color: #dc2626; /* red-600 */
            color: white;
            box-shadow: 0 4px 8px -2px rgba(220, 38, 38, 0.3);
        }
        .btn-danger:hover:not(:disabled) {
            background-color: #b91c1c; /* red-700 */
        }
        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .log-container::-webkit-scrollbar { width: 8px; }
        .log-container::-webkit-scrollbar-track { background: #e2e8f0; border-radius: 10px; } /* slate-200 */
        .log-container::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; } /* slate-400 */
        .log-container::-webkit-scrollbar-thumb:hover { background: #64748b; } /* slate-500 */
        
        .card {
            background-color: white;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.08), 0 4px 6px -4px rgba(0, 0, 0, 0.05);
            padding: 2.5rem; /* p-10 */
            margin-bottom: 2.5rem; /* mb-10 */
        }
        .stat-card {
            background-color: #f8fafc; /* slate-50 */
            padding: 1.5rem; /* p-6 */
            border-radius: 0.75rem; /* rounded-xl */
            border: 1px solid #e2e8f0; /* slate-200 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.04);
        }
        
        .marker-icon-base {
            display: flex; align-items: center; justify-content: center;
            font-weight: 700;
            font-size: 12px;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.25);
            box-shadow: 0 2px 5px rgba(0,0,0,0.25);
            border: 2px solid white;
        }
        .agent-available { background-color: #2563eb; } /* blue-600 */
        .agent-busy { background-color: #ea580c; } /* orange-600 */
        .order-pending { background-color: #16a34a; } /* green-600 */
        .order-assigned { background-color: #facc15; color: #713f12; } /* yellow-400, text-yellow-800 */

        input[type="range"] {
            -webkit-appearance: none; appearance: none; width: 100%; height: 12px;
            background: #cbd5e1; /* slate-300 */
            border-radius: 6px; outline: none; cursor: pointer;
            transition: background 0.15s ease-in-out;
        }
        input[type="range"]:hover {
            background: #94a3b8; /* slate-400 */
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 24px; height: 24px;
            background: #2563eb; /* blue-600 */
            border-radius: 50%; cursor: pointer; border: 4px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.15s ease-in-out;
        }
        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.1);
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px; height: 24px; background: #2563eb; /* blue-600 */
            border-radius: 50%; cursor: pointer; border: 4px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .simulation-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1.5rem; 
            align-items: flex-start; 
        }
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem; /* mb-2 */
        }
        .control-label label {
            font-weight: 500; /* font-medium */
        }
        .input-group {
            margin-bottom: 1rem; /* mb-4 */
        }
        .input-group label {
            display: block;
            font-weight: 500; /* font-medium */
            color: #374151; /* text-slate-700 */
            margin-bottom: 0.25rem; /* mb-1 */
        }
        .input-group input[type="number"], .input-group input[type="text"], .input-group select, .input-group input[type="checkbox"] {
            width: 100%;
            padding: 0.5rem 0.75rem; /* py-2 px-3 */
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #d1d5db; /* border-slate-300 */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }
         .input-group input[type="number"]:focus, .input-group input[type="text"]:focus, .input-group select:focus, .input-group input[type="checkbox"]:focus {
            border-color: #2563eb; /* blue-600 */
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 2px rgba(59,130,246,0.4); /* ring-blue-500/40 */
        }
        .input-group input[type="checkbox"] { /* Specific styling for checkbox */
            width: auto; /* Override width for checkbox */
            padding: 0;
            margin-right: 0.5rem;
            accent-color: #2563eb;
        }
        .checkbox-group label { /* Ensure label is clickable for checkbox */
             display: inline-flex; 
             align-items: center; 
             cursor: pointer;
        }

        .voronoi-cell-path { 
            stroke: #0ea5e9; /* sky-500 */
            stroke-width: 1.5px; 
            fill: false; 
            fill-opacity: 0; 
        }
         .checkbox-label { /* For clustering page specific checkbox */
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9rem;
            color: #475569; /* slate-600 */
        }
        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
            margin-right: 0.5rem; /* mr-2 */
            accent-color: #2563eb; /* blue-600 */
        }
        .simulation-stats-container, .optimization-results-container, #optimizationComparisonContainer {
            background-color: #e0f2fe; /* sky-100 */
            border: 1px solid #7dd3fc; /* sky-300 */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem; /* p-6 */
            margin-top: 2rem; /* mt-8 */
        }
        .simulation-stats-container h4, .optimization-results-container h4, #optimizationComparisonContainer h4 {
            color: #0c4a6e; /* sky-800 */
            margin-bottom: 1rem; /* mb-4 */
            border-bottom: 2px solid #38bdf8; /* sky-400 */
            padding-bottom: 0.5rem; /* pb-2 */
        }
        .simulation-stats-grid, .optimization-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Adjusted minmax */
            gap: 1rem; /* gap-4 */
        }
        .simulation-stats-grid p, .optimization-results-grid p, .optimization-results-container li {
            background-color: #f0f9ff; /* sky-50 */
            padding: 0.75rem; /* p-3 */
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #bae6fd; /* sky-200 */
            font-size: 0.9rem;
        }
        .simulation-stats-grid strong, .optimization-results-grid strong, .optimization-results-container strong {
            color: #075985; /* sky-700 */
        }
        .optimization-log {
            background-color: #1e293b; /* slate-800 */
            color: #e2e8f0; /* slate-200 */
            padding: 1rem; /* p-4 */
            border-radius: 0.5rem; /* rounded-lg */
            margin-top: 1rem; /* mt-4 */
            max-height: 350px; /* Increased height */
            overflow-y: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85rem; /* Slightly larger for readability */
            line-height: 1.4;
        }
         .log-message { margin-bottom: 0.25rem; }
        .log-info { color: #93c5fd; } /* Light blue for general info */
        .log-agent { color: #fdba74; } /* Orange for agent actions */
        .log-order { color: #86efac; } /* Green for order events */
        .log-system { color: #fde047; } /* Yellow for system/warnings */
        .log-error { color: #fda4af; font-weight: bold;} /* Red for errors */
        .log-system-bold { color: #fde047; font-weight: bold;} /* Yellow for system/warnings */

        .profile-zone {
            border: 1px solid #e2e8f0; /* slate-200 */
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
            background-color: #f8fafc; /* slate-50 */
        }
        .sector-select-container {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.5rem;
        }
        .sector-select-container label {
            display: block;
            margin-bottom: 0.25rem;
        }
        /* Table styling for optimization comparison */
        .comparison-table-container {
            overflow-x: auto; /* Allow horizontal scrolling for table on small screens */
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.85rem;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #cbd5e1; /* slate-300 */
            padding: 0.5rem 0.75rem;
            text-align: left;
        }
        .comparison-table th {
            background-color: #e2e8f0; /* slate-200 */
            color: #334155; /* slate-700 */
            font-weight: 600;
        }
        .comparison-table tbody tr:nth-child(even) {
            background-color: #f8fafc; /* slate-50 */
        }
        .comparison-table tbody tr:hover {
            background-color: #f1f5f9; /* slate-100 */
        }
        .chart-container {
            margin-top: 2rem;
            padding: 1rem;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

    </style>
</head>
<body class="bg-slate-100 text-slate-800">

    <header class="bg-white shadow-xl sticky top-0 z-50">
        <nav class="container mx-auto px-6 py-4">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <h1 class="text-3xl font-extrabold text-blue-700 tracking-tight">Chandigarh Logistics Sim</h1>
                <div class="flex flex-wrap justify-center space-x-1 sm:space-x-2 mt-3 md:mt-0">
                    <a href="#home" class="nav-link px-4 py-2 text-slate-700 hover:text-blue-700 transition-colors duration-150" onclick="showSection('home', this)">Home</a>
                    <a href="#clustering" class="nav-link px-4 py-2 text-slate-700 hover:text-blue-700 transition-colors duration-150" onclick="showSection('clustering', this)">Clustering & Voronoi</a>
                    <a href="#demandProfiles" class="nav-link px-4 py-2 text-slate-700 hover:text-blue-700 transition-colors duration-150" onclick="showSection('demandProfiles', this)">Demand Profiles</a>
                    <a href="#simulation" class="nav-link px-4 py-2 text-slate-700 hover:text-blue-700 transition-colors duration-150" onclick="showSection('simulation', this)">Simulation</a>
                    <a href="#workforceOptimization" class="nav-link px-4 py-2 text-slate-700 hover:text-blue-700 transition-colors duration-150" onclick="showSection('workforceOptimization', this)">Workforce Optimization</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="container mx-auto p-4 md:p-8 mt-8">
        <section id="home" class="content-section active">
            <div class="card">
                <h2 class="text-4xl font-bold mb-8 text-slate-800 border-b-4 border-blue-500 pb-4">Optimizing Last-Mile Delivery in Chandigarh</h2>
                <p class="mb-6 text-lg leading-relaxed text-slate-600">
                    This capstone project, undertaken by Rakshit Monga at the Indian Institute of Management Sirmaur, presents a comprehensive approach to optimizing last-mile delivery logistics within the urban context of Chandigarh. The study meticulously combines critical facets of logistics planning:
                </p>
                <ol class="list-decimal list-inside space-y-3 mb-6 text-lg text-slate-600">
                    <li class="pl-2"><strong class="text-slate-700">Advanced Demand Clustering:</strong> Strategically identifying optimal locations for dark stores by simulating realistic demand patterns.</li>
                    <li class="pl-2"><strong class="text-slate-700">Custom Demand Profiling:</strong> Define and save custom order generation profiles with multiple uniform and hotspot zones to simulate diverse demand scenarios.</li>
                    <li class="pl-2"><strong class="text-slate-700">Dynamic Delivery Simulation:</strong> Developing and evaluating a real-time system for agent assignment, order fulfillment, and operational efficiency, now with dynamic traffic and selectable demand profiles.</li>
                     <li class="pl-2"><strong class="text-slate-700">Workforce Optimization:</strong> An analytical tool to simulate different workforce sizes against varying demand to identify optimal agent counts.</li>
                </ol>
                <p class="mb-8 text-lg leading-relaxed text-slate-600">
                    The overarching goal is to furnish data-driven, actionable insights that promote efficient resource allocation, reduce delivery lead times, enhance operational resilience, and ultimately improve customer satisfaction in complex urban delivery networks.
                </p>

                <div class="bg-gradient-to-br from-blue-100 via-indigo-100 to-purple-100 p-8 rounded-xl border border-blue-200 shadow-lg">
                    <h3 class="text-2xl font-semibold mb-4 text-blue-800">Project Lead</h3>
                    <ul class="list-none space-y-1.5 text-slate-700 text-lg">
                        <li class="flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-6 h-6 mr-3 text-blue-600">
                                <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" />
                            </svg>
                            Rakshit Monga
                        </li>
                    </ul>
                    <p class="mt-4 text-sm text-slate-500 italic">Indian Institute of Management Sirmaur</p>
                </div>
                <p class="mt-8 text-lg text-slate-600">
                    Navigate through the sections using the menu above to explore the detailed clustering analysis methodology, interact with the live delivery simulation, or use the workforce optimization tool.
                </p>
            </div>
        </section>

        <section id="clustering" class="content-section">
            <div class="card">
                <h2 class="text-4xl font-bold mb-8 text-slate-800 border-b-4 border-blue-500 pb-4">Demand Clustering & Voronoi Analysis</h2>
                <p class="mb-6 leading-relaxed text-slate-600">
                    Configure the number of background and hotspot orders, and the desired number of dark stores. The system will generate demand points and use K-Means clustering to identify optimal dark store locations. Voronoi diagrams visualize their service areas. These dark stores can then be selected for Workforce Optimization scenarios.
                </p>
                
                <div class="mb-8 p-6 border-2 border-blue-200 rounded-xl bg-blue-50 shadow-md">
                    <h3 class="text-2xl font-semibold mb-4 text-blue-700">Configure Clustering Parameters</h3>
                    <div class="grid md:grid-cols-3 gap-6">
                        <div class="input-group">
                            <label for="numBackgroundOrders">Background Orders:</label>
                            <input type="number" id="numBackgroundOrders" value="700" min="0" step="50" class="w-full">
                        </div>
                        <div class="input-group">
                            <label for="numHotspotOrders">Hotspot Orders:</label>
                            <input type="number" id="numHotspotOrders" value="300" min="0" step="50" class="w-full">
                        </div>
                        <div class="input-group">
                            <label for="numDarkStoresForClustering">Number of Dark Stores:</label>
                            <input type="number" id="numDarkStoresForClustering" value="10" min="1" max="25" step="1" class="w-full">
                        </div>
                    </div>
                </div>

                <div class="grid md:grid-cols-2 gap-8 mb-10">
                    <div class="stat-card text-center p-8">
                        <h4 class="font-semibold text-xl mb-2 text-slate-500">Total Orders Simulated</h4>
                        <p id="totalOrdersDisplayClustering" class="text-5xl font-extrabold text-blue-600">1000</p>
                    </div>
                    <div class="stat-card text-center p-8">
                        <h4 class="font-semibold text-xl mb-2 text-slate-500">Dark Stores Identified</h4>
                        <p id="numDarkStoresDisplay" class="text-5xl font-extrabold text-blue-600">10</p>
                    </div>
                </div>
                <div id="clusteringMapVizContainer" class="mb-6 shadow-2xl rounded-xl overflow-hidden border-2 border-slate-200">
                    <div id="clusteringMapViz" class="w-full"></div>
                </div>
                 <div class="mb-4 text-center">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showOrderConnectionsToggle"> Show Order-to-Store Connections
                    </label>
                </div>
                <p class="text-md text-slate-500 mb-6 italic text-center">
                    Map Key: Chandigarh Boundary (Dark Outline), Voronoi Cell Outlines (Blue Lines), Orders (Blue/Purple Circles), Dark Stores (Red Markers).
                </p>
                 <div class="text-center">
                    <button id="regenerateClusteringBtn" class="btn btn-primary">Regenerate Clustering Data</button>
                 </div>
                 <div id="clusteringStats" class="mt-8 grid md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm bg-slate-100 p-6 rounded-lg border border-slate-200 shadow-inner">
                    <p class="italic text-slate-500 md:col-span-2 lg:col-span-3 text-center">Cluster statistics will appear here after generation.</p>
                 </div>
                 <div id="overallClusteringStats" class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg text-center">
                     <p><strong class="text-blue-700">Overall Average Order-to-Store Distance:</strong> <span id="overallAvgClusterDistance" class="font-semibold">N/A</span></p>
                     <p><strong class="text-blue-700">Overall Min Distance:</strong> <span id="overallMinClusterDistance" class="font-semibold">N/A</span></p>
                     <p><strong class="text-blue-700">Overall Max Distance:</strong> <span id="overallMaxClusterDistance" class="font-semibold">N/A</span></p>
                     <p><strong class="text-blue-700">Overall Std. Dev. Distance:</strong> <span id="overallStdDevClusterDistance" class="font-semibold">N/A</span></p>
                 </div>
            </div>
        </section>

        <section id="demandProfiles" class="content-section">
            <div class="card">
                <h2 class="text-4xl font-bold mb-8 text-slate-800 border-b-4 border-blue-500 pb-4">Custom Demand Profiles</h2>
                <p class="mb-6 leading-relaxed text-slate-600">
                    Define custom order generation profiles by combining uniform demand, specific hotspot zones, sector-based demand, or route-based demand. These profiles can then be selected in the "Simulation" tab.
                </p>

                <div class="grid md:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-2xl font-semibold mb-4 text-blue-700">Create/Edit Profile</h3>
                        <div class="input-group">
                            <label for="profileNameInput">Profile Name:</label>
                            <input type="text" id="profileNameInput" placeholder="e.g., Evening Rush Sector 17" class="w-full">
                        </div>
                        
                        <div id="profileZonesContainer" class="space-y-4 mb-4">
                            </div>

                        <button id="addZoneToProfileBtn" class="btn btn-secondary btn-sm mb-4">Add Zone</button>
                        <div class="flex space-x-2">
                            <button id="saveProfileBtn" class="btn btn-primary">Save Profile</button>
                            <button id="clearProfileFormBtn" class="btn btn-danger btn-sm">Clear Form</button>
                        </div>
                         <div id="profileCreationMapContainer" class="mt-6 hidden">
                            <h4 class="text-lg font-semibold text-center mb-2 text-slate-600">Set Hotspot/Route Point</h4>
                            <div id="profileCreationMap"></div>
                            <p class="text-sm text-center text-slate-500 mt-2">Click on map to set hotspot center or route points.</p>
                            <button id="finishCurrentRouteBtn" class="btn btn-secondary btn-sm mt-2 hidden">Finish Current Route Segment</button>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-2xl font-semibold mb-4 text-blue-700">Saved Profiles</h3>
                        <div id="savedProfilesListContainer" class="max-h-96 overflow-y-auto bg-slate-50 p-4 rounded-lg border border-slate-200">
                            <ul id="savedProfilesList" class="list-none space-y-2">
                                <li class="italic text-slate-500">No custom profiles saved yet.</li>
                            </ul>
                        </div>
                         <p class="text-sm text-slate-500 mt-4 italic">Note: Profiles are stored for the current session only.</p>
                    </div>
                </div>
            </div>
        </section>


        <section id="simulation" class="content-section">
            <div class="card">
                <h2 class="text-4xl font-bold mb-8 text-slate-800 border-b-4 border-blue-500 pb-4">Interactive Delivery Simulation</h2>
                
                <div class="mb-10 p-8 border-2 border-blue-300 rounded-xl bg-gradient-to-r from-blue-50 to-indigo-50 shadow-lg">
                    <h3 class="text-2xl font-semibold mb-6 text-blue-700 text-center">Configure Simulation Parameters</h3>
                    <div class="simulation-controls-grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
                        <div>
                            <div class="control-label">
                                <label for="numAgentsSlider" class="block text-md font-medium text-slate-700">Number of Agents:</label>
                                <span id="numAgentsValue" class="font-bold text-xl text-blue-700">5</span>
                            </div>
                            <input type="range" id="numAgentsSlider" min="1" max="10" value="5" class="mt-2">
                        </div>
                        <div>
                             <div class="control-label">
                                <label for="orderFrequencySlider" class="block text-md font-medium text-slate-700">Order Arrival Rate:</label>
                                <span id="orderFrequencyValue" class="font-bold text-xl text-blue-700">Medium</span>
                            </div>
                            <input type="range" id="orderFrequencySlider" min="1" max="5" value="3" class="mt-2">
                            <div class="text-sm text-slate-500 flex justify-between mt-1 px-1"><span>Slower</span><span></span><span>Faster</span></div>
                        </div>
                        <div>
                            <div class="control-label">
                                <label for="agentMinSpeedSlider" class="block text-md font-medium text-slate-700">Min Agent Speed (km/h):</label>
                                <span id="agentMinSpeedValue" class="font-bold text-xl text-blue-700">20</span>
                            </div>
                            <input type="range" id="agentMinSpeedSlider" min="10" max="30" value="20" step="1" class="mt-2">
                        </div>
                        <div>
                            <div class="control-label">
                                <label for="agentMaxSpeedSlider" class="block text-md font-medium text-slate-700">Max Agent Speed (km/h):</label>
                                <span id="agentMaxSpeedValue" class="font-bold text-xl text-blue-700">30</span>
                            </div>
                            <input type="range" id="agentMaxSpeedSlider" min="20" max="50" value="30" step="1" class="mt-2">
                        </div>
                        <div>
                            <div class="control-label">
                                <label for="handlingTimeSlider" class="block text-md font-medium text-slate-700">Store Handling Time (min):</label>
                                <span id="handlingTimeValue" class="font-bold text-xl text-blue-700">5</span>
                            </div>
                            <input type="range" id="handlingTimeSlider" min="1" max="15" value="5" step="1" class="mt-2">
                        </div>
                        <div class="input-group"> <label for="orderGenerationProfileSelect" class="block text-md font-medium text-slate-700">Order Generation Profile:</label>
                            <select id="orderGenerationProfileSelect" class="mt-1">
                                <option value="default_uniform" selected>Default: Uniform City-Wide</option>
                                <option value="default_focused">Default: Focused Around Dark Store</option>
                                </select>
                        </div>
                        <div id="defaultOrderSpreadContainer"> <div class="control-label">
                                <label for="orderSpreadSlider" class="block text-md font-medium text-slate-700">Order Location Spread (Default):</label>
                                <span id="orderSpreadValue" class="font-bold text-xl text-blue-700">Medium</span>
                            </div>
                            <input type="range" id="orderSpreadSlider" min="1" max="5" value="3" class="mt-2">
                             <div class="text-xs text-slate-500 flex justify-between mt-1 px-1"><span>Closer</span><span></span><span>Wider</span></div>
                        </div>
                        <div id="defaultOrderFocusRadiusContainer" class="input-group hidden"> <div class="control-label">
                                <label for="defaultOrderFocusRadiusSlider" class="block text-md font-medium text-slate-700">Focus Radius (km - Default):</label>
                                <span id="defaultOrderFocusRadiusValue" class="font-bold text-xl text-blue-700">3</span>
                            </div>
                            <input type="range" id="defaultOrderFocusRadiusSlider" min="1" max="5" value="3" step="0.5" class="mt-2">
                        </div>
                         <div class="input-group">
                            <label for="routeWaypointsSelect" class="block text-md font-medium text-slate-700">Route Complexity (Waypoints):</label>
                            <select id="routeWaypointsSelect" class="mt-1">
                                <option value="0">0 (Straight Lines)</option>
                                <option value="1" selected>1 Waypoint</option>
                                <option value="2">2 Waypoints</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="manualTrafficControl" class="block text-md font-medium text-slate-700">Base Traffic Condition:</label>
                            <select id="manualTrafficControl" class="mt-1">
                                <option value="1.0" selected>Medium (Normal)</option>
                                <option value="1.2">Light</option>
                                <option value="0.7">Heavy</option>
                            </select>
                        </div>
                        <div class="input-group checkbox-group items-center">
                            <input type="checkbox" id="enableDynamicTraffic" class="mr-2">
                            <label for="enableDynamicTraffic" class="text-md font-medium text-slate-700 cursor-pointer">Enable Dynamic Traffic</label>
                        </div>
                    </div>
                </div>

                <p class="mb-8 leading-relaxed text-slate-600 text-lg">
                    Adjust simulation parameters above. Click "Start Simulation" to observe agents and orders on the map. Agent routes are simplified for this web demonstration.
                </p>
                
                <div class="text-center text-slate-600 mb-4">
                    Simulation Time: <span id="simTimeDisplay" class="font-semibold text-3xl text-slate-800">0</span> minutes 
                    (<span id="currentTrafficStatus" class="text-sm">Traffic: Normal</span>)
                </div>

                <div class="grid lg:grid-cols-3 gap-x-8 gap-y-8">
                    <div class="lg:col-span-2 space-y-6">
                        <div id="simulationMap" class="w-full shadow-2xl rounded-xl overflow-hidden border-2 border-slate-200"></div>
                        <div class="flex flex-col sm:flex-row items-center justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                            <button id="startSimBtn" class="btn btn-primary w-full sm:flex-1">Start Simulation</button>
                            <button id="pauseSimBtn" class="btn btn-secondary w-full sm:flex-1">Pause Simulation</button>
                             <button id="resetSimBtn" class="btn btn-danger w-full sm:flex-1">Reset Simulation</button>
                        </div>
                    </div>

                    <div class="lg:col-span-1 space-y-6">
                        <div class="stat-card">
                            <h4 class="font-semibold text-xl mb-3 text-slate-700">Agent Status</h4>
                            <div id="agentStatusList" class="space-y-2 text-sm max-h-60 overflow-y-auto log-container p-4 bg-white rounded-lg border border-slate-200">
                                <p class="text-slate-500 italic">Agents will appear here...</p>
                            </div>
                        </div>
                        <div class="stat-card">
                            <h4 class="font-semibold text-xl mb-3 text-slate-700">Active Orders</h4>
                            <div id="pendingOrdersList" class="space-y-2 text-sm max-h-60 overflow-y-auto log-container p-4 bg-white rounded-lg border border-slate-200">
                                <p class="text-slate-500 italic">Active orders will appear here...</p>
                            </div>
                        </div>
                         <div class="stat-card">
                            <h4 class="font-semibold text-xl mb-3 text-slate-700">Simulation Log</h4>
                            <div id="simulationLog" class="text-xs space-y-1.5 h-72 overflow-y-auto bg-slate-900 text-slate-300 p-4 rounded-lg log-container font-mono">
                                <p class="log-system"><em>[SYS] Simulation log initialized.</em></p>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="simulationOverallStats" class="simulation-stats-container">
                    <h4 class="text-2xl font-semibold text-center">Simulation Statistics</h4>
                    <div class="simulation-stats-grid">
                        <p><strong >Total Orders Generated:</strong> <span id="statsTotalOrdersGenerated">0</span></p>
                        <p><strong >Total Orders Delivered:</strong> <span id="statsTotalOrdersDelivered">0</span></p>
                        <p><strong >Avg. Delivery Time:</strong> <span id="statsAvgDeliveryTime">N/A</span></p>
                        <p><strong >Min Delivery Time:</strong> <span id="statsMinDeliveryTime">N/A</span></p>
                        <p><strong >Max Delivery Time:</strong> <span id="statsMaxDeliveryTime">N/A</span></p>
                        <p><strong >Std. Dev. Delivery Time:</strong> <span id="statsStdDevDeliveryTime">N/A</span></p>
                        <p><strong >Avg. Order Wait Time:</strong> <span id="statsAvgOrderWaitTime">N/A</span></p>
                        <p><strong >Avg. Agent Utilization:</strong> <span id="statsAvgAgentUtilization">N/A</span></p>
                        <p><strong >Total Agent Travel Time:</strong> <span id="statsTotalAgentTravelTime">0</span> min</p>
                        <p><strong >Total Agent Handling Time:</strong> <span id="statsTotalAgentHandlingTime">0</span> min</p>
                        <p><strong >Total Simulation Runtime:</strong> <span id="statsTotalSimTime">0</span> min</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="workforceOptimization" class="content-section">
            <div class="card">
                <h2 class="text-4xl font-bold mb-8 text-slate-800 border-b-4 border-blue-500 pb-4">Workforce Optimization Analysis</h2>
                <p class="mb-6 leading-relaxed text-slate-600">
                    This tool helps estimate the optimal number of delivery agents required to achieve a target average delivery time. It runs multiple short simulations with varying numbers of agents.
                    Select a specific dark store (identified from the "Clustering & Voronoi" section) for this optimization scenario. Other parameters like agent speed, handling time, order spread, route complexity, and traffic conditions are taken from the main "Simulation" page settings.
                </p>

                <div class="mb-8 p-6 border-2 border-blue-200 rounded-xl bg-blue-50 shadow-md">
                    <h3 class="text-2xl font-semibold mb-4 text-blue-700">Optimization Parameters</h3>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div class="input-group">
                            <label for="optTargetDeliveryTime">Target Avg. Delivery Time (min):</label>
                            <input type="number" id="optTargetDeliveryTime" value="15" min="5" step="1" class="w-full">
                        </div>
                        <div class="input-group">
                            <label for="optSelectDarkStore">Select Dark Store for Scenario:</label>
                            <select id="optSelectDarkStore" class="w-full">
                                <option value="">-- Run Clustering First --</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="optOrdersPerIteration">Orders per Iteration (Target):</label>
                            <input type="number" id="optOrdersPerIteration" value="10" min="1" step="1" class="w-full">
                        </div>
                        <div class="input-group">
                            <label for="optMinAgents">Min Agents to Test:</label>
                            <input type="number" id="optMinAgents" value="1" min="1" max="25" step="1" class="w-full">
                        </div>
                        <div class="input-group">
                            <label for="optMaxAgents">Max Agents to Test:</label>
                            <input type="number" id="optMaxAgents" value="15" min="1" max="25" step="1" class="w-full">
                        </div>
                         <div class="input-group md:col-span-2"> 
                            <label for="optMaxSimTimePerIteration">Max Sim Time per Iteration (min):</label>
                            <input type="number" id="optMaxSimTimePerIteration" value="120" min="1" step="1" class="w-full">
                        </div>
                    </div>
                    <div class="mt-6 text-center">
                        <button id="runOptimizationBtn" class="btn btn-primary">Run Workforce Optimization</button>
                    </div>
                </div>
                
                <div id="optimizationMapContainer" class="mb-6 shadow-xl rounded-xl overflow-hidden border-2 border-slate-200">
                     <h4 class="text-xl font-semibold text-center p-4 bg-slate-100 border-b border-slate-300">Scenario Map (Best Agent Count)</h4>
                    <div id="optimizationMapViz" class="w-full"></div>
                </div>

                <div id="optimizationComparisonContainer" class="optimization-results-container hidden">
                    <h4 class="text-2xl font-semibold text-center">Iteration Comparison Table</h4>
                    <div class="comparison-table-container">
                        <table id="optimizationComparisonTable" class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Agents</th>
                                    <th>Generated Orders</th>
                                    <th>Delivered Orders</th>
                                    <th>Avg. Delivery Time (min)</th>
                                    <th>Min Delivery Time (min)</th>
                                    <th>Max Delivery Time (min)</th>
                                    <th>Std. Dev. Delivery Time (min)</th>
                                    <th>Avg. Agent Utilization (%)</th>
                                    <th>Avg. Order Wait Time (min)</th>
                                    <th>Undelivered Orders</th>
                                </tr>
                            </thead>
                            <tbody>
                                </tbody>
                        </table>
                    </div>
                </div>

                 <div id="optimizationChartsContainer" class="hidden mt-8 grid md:grid-cols-2 gap-8">
                    <div class="chart-container">
                        <h4 class="text-xl font-semibold text-center mb-2">Agents vs. Avg. Delivery Time</h4>
                        <canvas id="deliveryTimeChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h4 class="text-xl font-semibold text-center mb-2">Agents vs. Avg. Utilization</h4>
                        <canvas id="utilizationChart"></canvas>
                    </div>
                </div>


                <div id="optimizationResultsContainer" class="optimization-results-container hidden">
                    <h4 class="text-2xl font-semibold text-center">Optimization Results (Best Scenario)</h4>
                    <div class="optimization-results-grid">
                        <p><strong >Optimal Agents Found:</strong> <span id="optResultAgents">N/A</span></p>
                        <p><strong >Achieved Avg. Delivery Time:</strong> <span id="optResultAvgTime">N/A</span></p>
                        <p><strong >Target Avg. Delivery Time:</strong> <span id="optResultTargetTime">N/A</span></p>
                        <p><strong >Min Delivery Time:</strong> <span id="optResultMinDelTime">N/A</span></p>
                        <p><strong >Max Delivery Time:</strong> <span id="optResultMaxDelTime">N/A</span></p>
                        <p><strong >Std. Dev. Delivery Time:</strong> <span id="optResultStdDevDelTime">N/A</span></p>
                        <p><strong >Avg. Agent Utilization:</strong> <span id="optResultAvgUtilization">N/A</span></p>
                        <p><strong >Avg. Order Wait Time:</strong> <span id="optResultAvgWaitTime">N/A</span></p>
                        <p><strong >Undelivered Orders:</strong> <span id="optResultUndelivered">N/A</span></p>
                    </div>
                    <div class="mt-4">
                        <h5 class="text-xl font-semibold text-slate-700 mb-2">Dark Store Analysis (for Optimal Scenario):</h5>
                        <ul id="optDarkStoreDistances" class="list-disc list-inside space-y-1">
                            </ul>
                        <p class="mt-2"><strong >Overall Avg. Order-to-Store Distance:</strong> <span id="optOverallAvgDistance">N/A</span></p>
                    </div>
                    <h5 class="text-xl font-semibold text-slate-700 mt-6 mb-2">Optimization Log (Agent Count vs. Avg. Delivery Time):</h5>
                    <div id="optimizationLog" class="optimization-log">
                        <p class="log-system"><em>[SYS] Optimization process log will appear here...</em></p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="text-center py-16 mt-12 bg-slate-900 text-slate-400">
        <p class="text-slate-300 text-lg">&copy; <span id="currentYear"></span> Rakshit Monga - IIM Sirmaur.</p>
        <p class="text-md mt-2">Chandigarh Last-Mile Logistics Optimization Project</p>
        <div class="mt-8">
            <button id="toggleSectorCoordsBtn" class="btn btn-secondary btn-sm">Show/Hide Sector Coordinates</button>
            <div id="sectorCoordinatesContainer" class="hidden mt-4 text-left max-w-2xl mx-auto bg-slate-800 p-4 rounded-lg text-sm">
                <h4 class="text-lg font-semibold text-slate-200 mb-2 text-center">Chandigarh Sector Coordinates (Approximate Centers)</h4>
                <pre id="sectorCoordinatesList" class="text-slate-300 whitespace-pre-wrap"></pre>
            </div>
        </div>
    </footer>

    <script>
        // --- Global Variables ---
        let globalClusteredDarkStores = []; // To store dark stores from clustering section: {id, name, lat, lng}
        let customDemandProfiles = []; // To store user-defined demand profiles
        let profileCreationMapInstance; // Map instance for profile creation UI
        let tempProfileZones = []; // For building a profile in the UI
        let tempZoneMarkers = []; // Markers on the profile creation map
        let currentEditingZoneId = null; // To track which zone's lat/lng is being set by map click
        let currentRoutePoints = []; // For route-based profile zone definition
        let currentRoutePolylineLayer = null; // Leaflet layer for the route being drawn
        let deliveryTimeChartInstance = null;
        let utilizationChartInstance = null;


        // --- Chandigarh Sector Data (Approximate Centers) ---
        const chandigarhSectors = [
            { name: "Sector 1 (Capitol Complex)", lat: 30.742, lng: 76.784 }, { name: "Sector 2", lat: 30.749, lng: 76.790 },
            { name: "Sector 3", lat: 30.745, lng: 76.794 }, { name: "Sector 4", lat: 30.750, lng: 76.799 },
            { name: "Sector 5", lat: 30.755, lng: 76.804 }, { name: "Sector 6", lat: 30.762, lng: 76.809 },
            { name: "Sector 7", lat: 30.738, lng: 76.799 }, { name: "Sector 8", lat: 30.742, lng: 76.804 },
            { name: "Sector 9", lat: 30.736, lng: 76.788 }, { name: "Sector 10", lat: 30.739, lng: 76.784 },
            { name: "Sector 11", lat: 30.744, lng: 76.778 }, { name: "Sector 12 (PGIMER)", lat: 30.758, lng: 76.767 },
            { name: "Sector 14 (Panjab University)", lat: 30.755, lng: 76.760 }, { name: "Sector 15", lat: 30.749, lng: 76.772 },
            { name: "Sector 16", lat: 30.738, lng: 76.778 }, { name: "Sector 17 (City Center)", lat: 30.733, lng: 76.781 },
            { name: "Sector 18", lat: 30.730, lng: 76.790 }, { name: "Sector 19", lat: 30.725, lng: 76.795 },
            { name: "Sector 20", lat: 30.720, lng: 76.800 }, { name: "Sector 21", lat: 30.716, lng: 76.793 },
            { name: "Sector 22", lat: 30.730, lng: 76.774 }, { name: "Sector 23", lat: 30.740, lng: 76.765 },
            { name: "Sector 24", lat: 30.749, lng: 76.758 }, { name: "Sector 25", lat: 30.755, lng: 76.750 },
            { name: "Sector 26 (Grain Market)", lat: 30.735, lng: 76.805 }, { name: "Sector 27", lat: 30.720, lng: 76.787 },
            { name: "Sector 28", lat: 30.715, lng: 76.782 }, { name: "Sector 29", lat: 30.708, lng: 76.788 },
            { name: "Sector 30", lat: 30.704, lng: 76.781 }, { name: "Sector 31", lat: 30.698, lng: 76.795 },
            { name: "Sector 32", lat: 30.710, lng: 76.775 }, { name: "Sector 33", lat: 30.718, lng: 76.770 },
            { name: "Sector 34", lat: 30.725, lng: 76.765 }, { name: "Sector 35", lat: 30.730, lng: 76.760 },
            { name: "Sector 36", lat: 30.738, lng: 76.755 }, { name: "Sector 37", lat: 30.745, lng: 76.750 },
            { name: "Sector 38", lat: 30.750, lng: 76.743 }, { name: "Sector 38 West", lat: 30.748, lng: 76.735 },
            { name: "Sector 39", lat: 30.760, lng: 76.738 }, { name: "Sector 40", lat: 30.755, lng: 76.730 },
            { name: "Sector 41", lat: 30.748, lng: 76.725 }, { name: "Sector 42", lat: 30.735, lng: 76.748 },
            { name: "Sector 43 (ISBT)", lat: 30.728, lng: 76.755 }, { name: "Sector 44", lat: 30.720, lng: 76.760 },
            { name: "Sector 45", lat: 30.715, lng: 76.765 }, { name: "Sector 46", lat: 30.708, lng: 76.770 },
            { name: "Sector 47", lat: 30.700, lng: 76.775 }, { name: "Sector 48", lat: 30.690, lng: 76.765 },
            { name: "Sector 49", lat: 30.695, lng: 76.755 }, { name: "Sector 50", lat: 30.705, lng: 76.750 },
            { name: "Sector 51", lat: 30.715, lng: 76.745 }, { name: "Sector 52", lat: 30.725, lng: 76.740 },
            { name: "Sector 53", lat: 30.700, lng: 76.730 }, { name: "Sector 54 (Mohali)", lat: 30.690, lng: 76.720 }, 
            { name: "Sector 55", lat: 30.730, lng: 76.725 }, { name: "Sector 56", lat: 30.740, lng: 76.720 },
            { name: "Industrial Area Phase 1", lat: 30.710, lng: 76.790 }, { name: "Industrial Area Phase 2", lat: 30.695, lng: 76.780 },
            { name: "Manimajra", lat: 30.725, lng: 76.835 }, { name: "Dhanas", lat: 30.760, lng: 76.720 },
        ];


        // --- Navigation ---
        const navLinks = document.querySelectorAll('.nav-link');
        const contentSections = document.querySelectorAll('.content-section');

        function showSection(sectionId, clickedLink) {
            contentSections.forEach(section => section.classList.remove('active'));
            navLinks.forEach(link => link.classList.remove('nav-active'));

            const targetSection = document.getElementById(sectionId);
            if(targetSection) targetSection.classList.add('active');
            
            if (clickedLink) {
                clickedLink.classList.add('nav-active');
            } else {
                 const activeLink = document.querySelector(`.nav-link[href="#${sectionId}"]`);
                 if(activeLink) activeLink.classList.add('nav-active');
            }
            
            if (sectionId === 'simulation' && !simulationMapInstance) {
                initSimulationMap();
            }
            if (sectionId === 'clustering' && !clusteringMapInstance) {
                initClusteringMapVisualisation();
            }
            if (sectionId === 'demandProfiles' && !profileCreationMapInstance) {
                 initProfileCreationMap();
            }
            if (sectionId === 'workforceOptimization') {
                if (!optimizationMapInstance) {
                    initOptimizationMapVisualisation(); 
                }
                populateDarkStoreSelector(); 
            }
            if (sectionId === 'simulation') { // When switching to simulation tab
                populateOrderGenerationProfileSelector();
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            const hash = window.location.hash.substring(1);
            const validSection = hash && document.getElementById(hash);
            showSection(validSection ? hash : 'home', validSection ? document.querySelector(`.nav-link[href="#${hash}"]`) : document.querySelector('.nav-link[href="#home"]'));
            
            const currentYearEl = document.getElementById('currentYear');
            if(currentYearEl) currentYearEl.textContent = new Date().getFullYear();
            
            // Slider initializations
            const numAgentsSliderEl = document.getElementById('numAgentsSlider');
            const numAgentsValueEl = document.getElementById('numAgentsValue');
            if (numAgentsSliderEl && numAgentsValueEl) {
                numAgentsValueEl.textContent = numAgentsSliderEl.value;
                numAgentsSliderEl.addEventListener('input', (event) => {
                    numAgentsValueEl.textContent = event.target.value;
                });
            }
            const orderFrequencySliderEl = document.getElementById('orderFrequencySlider');
            const orderFrequencyValueEl = document.getElementById('orderFrequencyValue');
            if (orderFrequencySliderEl && orderFrequencyValueEl) {
                const freqMap = {1: "Very Low", 2: "Low", 3: "Medium", 4: "High", 5: "Very High"};
                orderFrequencyValueEl.textContent = freqMap[orderFrequencySliderEl.value];
                orderFrequencySliderEl.addEventListener('input', (event) => {
                    orderFrequencyValueEl.textContent = freqMap[event.target.value];
                });
            }
            
            const agentMinSpeedSliderEl = document.getElementById('agentMinSpeedSlider');
            const agentMinSpeedValueEl = document.getElementById('agentMinSpeedValue');
             if (agentMinSpeedSliderEl && agentMinSpeedValueEl) {
                agentMinSpeedValueEl.textContent = agentMinSpeedSliderEl.value;
                agentMinSpeedSliderEl.addEventListener('input', (event) => {
                    agentMinSpeedValueEl.textContent = event.target.value;
                    MIN_AGENT_SPEED = parseInt(event.target.value);
                    const agentMaxSpeedSliderEl_local = document.getElementById('agentMaxSpeedSlider'); 
                    const agentMaxSpeedValueEl_local = document.getElementById('agentMaxSpeedValue'); 
                    if (agentMaxSpeedSliderEl_local && MIN_AGENT_SPEED > parseInt(agentMaxSpeedSliderEl_local.value)) {
                        agentMaxSpeedSliderEl_local.value = event.target.value;
                        if(agentMaxSpeedValueEl_local) agentMaxSpeedValueEl_local.textContent = event.target.value;
                        MAX_AGENT_SPEED = MIN_AGENT_SPEED;
                    }
                });
            }
            const agentMaxSpeedSliderEl = document.getElementById('agentMaxSpeedSlider');
            const agentMaxSpeedValueEl = document.getElementById('agentMaxSpeedValue');
            if (agentMaxSpeedSliderEl && agentMaxSpeedValueEl) {
                agentMaxSpeedValueEl.textContent = agentMaxSpeedSliderEl.value;
                agentMaxSpeedSliderEl.addEventListener('input', (event) => {
                    agentMaxSpeedValueEl.textContent = event.target.value;
                    MAX_AGENT_SPEED = parseInt(event.target.value);
                    const agentMinSpeedSliderEl_local = document.getElementById('agentMinSpeedSlider'); 
                    const agentMinSpeedValueEl_local = document.getElementById('agentMinSpeedValue'); 
                     if (agentMinSpeedSliderEl_local && MAX_AGENT_SPEED < parseInt(agentMinSpeedSliderEl_local.value)) {
                        agentMinSpeedSliderEl_local.value = event.target.value;
                        if(agentMinSpeedValueEl_local) agentMinSpeedValueEl_local.textContent = event.target.value;
                        MIN_AGENT_SPEED = MAX_AGENT_SPEED;
                    }
                });
            }
            const handlingTimeSliderEl = document.getElementById('handlingTimeSlider');
            const handlingTimeValueEl = document.getElementById('handlingTimeValue');
            if (handlingTimeSliderEl && handlingTimeValueEl) {
                handlingTimeValueEl.textContent = handlingTimeSliderEl.value;
                handlingTimeSliderEl.addEventListener('input', (event) => {
                    handlingTimeValueEl.textContent = event.target.value;
                    FIXED_HANDLING_TIME_PER_ORDER = parseInt(event.target.value);
                });
            }
            const orderSpreadSliderEl = document.getElementById('orderSpreadSlider'); // For default profiles
            const orderSpreadValueEl = document.getElementById('orderSpreadValue');
            if(orderSpreadSliderEl && orderSpreadValueEl){
                const spreadMap = {1: "Very Close", 2: "Close", 3: "Medium", 4: "Wide", 5: "Very Wide"};
                orderSpreadValueEl.textContent = spreadMap[orderSpreadSliderEl.value];
                orderSpreadSliderEl.addEventListener('input', (event) => {
                    orderSpreadValueEl.textContent = spreadMap[event.target.value];
                    ORDER_LOCATION_SPREAD_FACTOR = orderSpreadFactors[event.target.value];
                });
            }
            const defaultOrderFocusRadiusSliderEl = document.getElementById('defaultOrderFocusRadiusSlider');
            const defaultOrderFocusRadiusValueEl = document.getElementById('defaultOrderFocusRadiusValue');
            if (defaultOrderFocusRadiusSliderEl && defaultOrderFocusRadiusValueEl) {
                defaultOrderFocusRadiusValueEl.textContent = defaultOrderFocusRadiusSliderEl.value;
                defaultOrderFocusRadiusSliderEl.addEventListener('input', (event) => {
                    defaultOrderFocusRadiusValueEl.textContent = event.target.value;
                });
            }

            const routeWaypointsSelectEl = document.getElementById('routeWaypointsSelect');
            if (routeWaypointsSelectEl) {
                routeWaypointsSelectEl.addEventListener('change', (event) => {
                    NUM_WAYPOINTS = parseInt(event.target.value);
                });
            }
            const manualTrafficControlEl = document.getElementById('manualTrafficControl');
            if (manualTrafficControlEl) {
                manualTrafficControlEl.addEventListener('change', (event) => {
                    MANUAL_TRAFFIC_FACTOR = parseFloat(event.target.value);
                    if(!document.getElementById('enableDynamicTraffic').checked) {
                         updateTrafficStatusDisplay(MANUAL_TRAFFIC_FACTOR);
                    }
                });
            }
            const dynamicTrafficCheckbox = document.getElementById('enableDynamicTraffic');
            if (dynamicTrafficCheckbox) {
                dynamicTrafficCheckbox.addEventListener('change', (event) => {
                    if(!event.target.checked) { 
                        MANUAL_TRAFFIC_FACTOR = parseFloat(manualTrafficControlEl.value);
                        updateTrafficStatusDisplay(MANUAL_TRAFFIC_FACTOR);
                    } else {
                         logMessageSim("Dynamic traffic enabled.", 'SYSTEM');
                    }
                });
            }
            const orderGenerationProfileSelectEl = document.getElementById('orderGenerationProfileSelect');
            const defaultOrderSpreadContainerEl = document.getElementById('defaultOrderSpreadContainer');
            const defaultOrderFocusRadiusContainerEl = document.getElementById('defaultOrderFocusRadiusContainer');

            if (orderGenerationProfileSelectEl) {
                orderGenerationProfileSelectEl.addEventListener('change', (event) => {
                    const selectedProfile = event.target.value;
                    if (selectedProfile === 'default_uniform') {
                        defaultOrderSpreadContainerEl.classList.remove('hidden');
                        defaultOrderFocusRadiusContainerEl.classList.add('hidden');
                    } else if (selectedProfile === 'default_focused') {
                        defaultOrderSpreadContainerEl.classList.add('hidden');
                        defaultOrderFocusRadiusContainerEl.classList.remove('hidden');
                    } else { // Custom profile selected
                        defaultOrderSpreadContainerEl.classList.add('hidden');
                        defaultOrderFocusRadiusContainerEl.classList.add('hidden');
                    }
                });
                 // Initial check
                if (orderGenerationProfileSelectEl.value === 'default_focused') {
                    defaultOrderSpreadContainerEl.classList.add('hidden');
                    defaultOrderFocusRadiusContainerEl.classList.remove('hidden');
                } else if (orderGenerationProfileSelectEl.value !== 'default_uniform') {
                    defaultOrderSpreadContainerEl.classList.add('hidden');
                    defaultOrderFocusRadiusContainerEl.classList.add('hidden');
                }
            }


            const bgOrderInput = document.getElementById('numBackgroundOrders');
            const hsOrderInput = document.getElementById('numHotspotOrders');
            const totalOrderDisplay = document.getElementById('totalOrdersDisplayClustering');
            const numDarkStoresClusteringInput = document.getElementById('numDarkStoresForClustering');


            function updateTotalOrderDisplay() {
                if (bgOrderInput && hsOrderInput && totalOrderDisplay) {
                    const bgCount = parseInt(bgOrderInput.value) || 0;
                    const hsCount = parseInt(hsOrderInput.value) || 0;
                    totalOrderDisplay.textContent = bgCount + hsCount;
                }
            }
            if (bgOrderInput) bgOrderInput.addEventListener('input', updateTotalOrderDisplay);
            if (hsOrderInput) hsOrderInput.addEventListener('input', updateTotalOrderDisplay);
            if (numDarkStoresClusteringInput && numDarkStoresDisplay) {
                 numDarkStoresDisplay.textContent = numDarkStoresClusteringInput.value; 
                 numDarkStoresClusteringInput.addEventListener('input', (event) => { 
                    numDarkStoresDisplay.textContent = event.target.value;
                });
            }
            updateTotalOrderDisplay(); 

            const runOptimizationBtn = document.getElementById('runOptimizationBtn');
            if (runOptimizationBtn) {
                runOptimizationBtn.addEventListener('click', runWorkforceOptimization);
            }
             
            if (document.getElementById('workforceOptimization').classList.contains('active') && !optimizationMapInstance) {
                initOptimizationMapVisualisation();
                populateDarkStoreSelector();
            }
            if (document.getElementById('demandProfiles').classList.contains('active') && !profileCreationMapInstance) {
                initProfileCreationMap();
            }
            updateTrafficStatusDisplay(MANUAL_TRAFFIC_FACTOR); 

            // Demand Profile UI Listeners
            document.getElementById('addZoneToProfileBtn').addEventListener('click', addZoneToProfileForm);
            document.getElementById('saveProfileBtn').addEventListener('click', saveCustomDemandProfile);
            document.getElementById('clearProfileFormBtn').addEventListener('click', clearProfileForm);
            updateSavedProfilesList(); // Initial population

            // Sector Coordinates Toggle
            const toggleSectorBtn = document.getElementById('toggleSectorCoordsBtn');
            const sectorCoordsContainer = document.getElementById('sectorCoordinatesContainer');
            const sectorCoordsListEl = document.getElementById('sectorCoordinatesList');
            
            // Populate sector coordinates
            let sectorListHTML = "";
            chandigarhSectors.forEach(sector => {
                sectorListHTML += `${sector.name}: ${sector.lat.toFixed(4)}, ${sector.lng.toFixed(4)}\n`;
            });
            sectorCoordsListEl.textContent = sectorListHTML;

            toggleSectorBtn.addEventListener('click', () => {
                sectorCoordsContainer.classList.toggle('hidden');
            });

        });

        // --- Chandigarh Boundary ---
        const chandigarhGeoJsonPolygon = [ 
            [76.6827, 30.7683], [76.7031, 30.7925], [76.7327, 30.8067], [76.7639, 30.8105], 
            [76.7958, 30.8063], [76.8234, 30.7909], [76.8404, 30.7688], [76.8468, 30.7406], 
            [76.8397, 30.7123], [76.8227, 30.6882], [76.7915, 30.6693], [76.7624, 30.6635], 
            [76.7312, 30.6698], [76.7000, 30.6861], [76.6789, 30.7153], [76.6765, 30.7432],
            [76.6827, 30.7683] 
        ];
        const chandigarhLeafletCoords = chandigarhGeoJsonPolygon.map(p => [p[1], p[0]]); 
        
        let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
        chandigarhLeafletCoords.forEach(coord => {
            if (coord[0] < minLat) minLat = coord[0];
            if (coord[0] > maxLat) maxLat = coord[0];
            if (coord[1] < minLng) minLng = coord[1];
            if (coord[1] > maxLng) maxLng = coord[1];
        });
        const chandigarhBounds = L.latLngBounds(L.latLng(minLat, minLng), L.latLng(maxLat, maxLng));
        const chandigarhCenter = chandigarhBounds.getCenter(); // {lat, lng}

        function isPointInPolygon(point, polygonCoords) { 
            // point is [lng, lat] for this function (consistent with GeoJSON)
            let x = point[0], y = point[1];
            let inside = false;
            for (let i = 0, j = polygonCoords.length - 1; i < polygonCoords.length; j = i++) {
                let xi = polygonCoords[i][0], yi = polygonCoords[i][1]; // polygonCoords are [lng, lat]
                let xj = polygonCoords[j][0], yj = polygonCoords[j][1];
                let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // --- Clustering Analysis Map Logic ---
        let clusteringMapInstance;
        let demandPointsLayerGroup; 
        let darkStoreMarkersLayerGroup;
        let voronoiLayerGroup; 
        let cityBoundaryOutlineLayer; 
        let orderToStoreLinesLayerGroup; 

        const regenerateClusteringBtn = document.getElementById('regenerateClusteringBtn');
        const clusteringStatsDiv = document.getElementById('clusteringStats');
        const numBackgroundOrdersInput = document.getElementById('numBackgroundOrders');
        const numHotspotOrdersInput = document.getElementById('numHotspotOrders');
        const showOrderConnectionsToggle = document.getElementById('showOrderConnectionsToggle');
        const numDarkStoresDisplay = document.getElementById('numDarkStoresDisplay');
        const numDarkStoresClusteringInput = document.getElementById('numDarkStoresForClustering');


        function initClusteringMapVisualisation() {
            if (clusteringMapInstance) { 
                clusteringMapInstance.remove(); 
                clusteringMapInstance = null;
            }
            clusteringMapInstance = L.map('clusteringMapViz').setView([chandigarhCenter.lat, chandigarhCenter.lng], 12);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                errorTileUrl: 'https://via.placeholder.com/256?text=Map+Tiles+Unavailable' 
            }).on('tileerror', function(e){
                console.error('Tile load error:', e);
            }).addTo(clusteringMapInstance);
            
            voronoiLayerGroup = L.layerGroup().addTo(clusteringMapInstance); 
            demandPointsLayerGroup = L.layerGroup().addTo(clusteringMapInstance);
            darkStoreMarkersLayerGroup = L.layerGroup().addTo(clusteringMapInstance);
            orderToStoreLinesLayerGroup = L.layerGroup(); 
            
            cityBoundaryOutlineLayer = L.polygon(chandigarhLeafletCoords, { 
                color: '#334155', 
                weight: 3, 
                fill: false, 
                dashArray: '5, 5', 
                interactive: false 
            });
            
            generateAndDisplayClusteringData();

            if(showOrderConnectionsToggle) {
                showOrderConnectionsToggle.addEventListener('change', () => {
                    if (showOrderConnectionsToggle.checked) {
                        if (!clusteringMapInstance.hasLayer(orderToStoreLinesLayerGroup)) {
                            orderToStoreLinesLayerGroup.addTo(clusteringMapInstance);
                        }
                    } else {
                        if (clusteringMapInstance.hasLayer(orderToStoreLinesLayerGroup)) {
                            clusteringMapInstance.removeLayer(orderToStoreLinesLayerGroup);
                        }
                    }
                });
            }
        }

        if(regenerateClusteringBtn){
            regenerateClusteringBtn.addEventListener('click', () => {
                if(clusteringMapInstance) { generateAndDisplayClusteringData(); } 
                else { initClusteringMapVisualisation(); }
            });
        }
        
        // Returns points as {lat, lng}
        function generateUniformPointInPolygon(numPoints, polygonGeoJsonCoords) {
            const points = [];
            let attempts = 0;
            const localBounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
            polygonGeoJsonCoords.forEach(p => { // p is [lng, lat]
                if (p[0] < localBounds.minX) localBounds.minX = p[0]; 
                if (p[0] > localBounds.maxX) localBounds.maxX = p[0];
                if (p[1] < localBounds.minY) localBounds.minY = p[1]; 
                if (p[1] > localBounds.maxY) localBounds.maxY = p[1];
            });

            if (numPoints <= 0) return points;

            while (points.length < numPoints && attempts < numPoints * 500) { 
                attempts++;
                const lng = Math.random() * (localBounds.maxX - localBounds.minX) + localBounds.minX;
                const lat = Math.random() * (localBounds.maxY - localBounds.minY) + localBounds.minY;
                if (isPointInPolygon([lng, lat], polygonGeoJsonCoords)) { // isPointInPolygon expects [lng, lat]
                    points.push({ lat, lng }); // Store as {lat, lng}
                }
            }
            return points;
        }
        
        // center is {lat, lng}, returns points as {lat, lng}
        function generateGaussianPointsInPolygon(center, sigmaDegrees, numPoints, polygonGeoJsonCoords) {
            const points = [];
            let attempts = 0;
            if (numPoints <= 0) return points;
            while (points.length < numPoints && attempts < numPoints * 500) { 
                attempts++;
                let u, v, s; 
                do { u = Math.random() * 2 - 1; v = Math.random() * 2 - 1; s = u * u + v * v; } while (s >= 1 || s === 0);
                const mul = Math.sqrt(-2.0 * Math.log(s) / s);
                const lng = center.lng + (sigmaDegrees * u * mul); 
                const lat = center.lat + (sigmaDegrees * v * mul);
                if (isPointInPolygon([lng, lat], polygonGeoJsonCoords)) { 
                    points.push({ lat, lng }); 
                }
            }
            return points;
        }

        function generateAndDisplayClusteringData(){
            if(!clusteringMapInstance || !demandPointsLayerGroup || !darkStoreMarkersLayerGroup || !voronoiLayerGroup) {
                console.error("Map or critical layer group not initialized in generateAndDisplayClusteringData.");
                return;
            }
            demandPointsLayerGroup.clearLayers(); 
            darkStoreMarkersLayerGroup.clearLayers(); 
            voronoiLayerGroup.clearLayers(); 
            if (orderToStoreLinesLayerGroup) orderToStoreLinesLayerGroup.clearLayers(); 
            globalClusteredDarkStores = []; 

            if(cityBoundaryOutlineLayer && clusteringMapInstance.hasLayer(cityBoundaryOutlineLayer)) { 
                clusteringMapInstance.removeLayer(cityBoundaryOutlineLayer);
            }
            if(clusteringStatsDiv) clusteringStatsDiv.innerHTML = '<p class="italic text-slate-500 md:col-span-2 lg:col-span-3 text-center">Generating cluster statistics...</p>';
            
            const backgroundCount = parseInt(numBackgroundOrdersInput.value) || 700;
            const hotspotCount = parseInt(numHotspotOrdersInput.value) || 300;
            const totalPoints = backgroundCount + hotspotCount;
            document.getElementById('totalOrdersDisplayClustering').textContent = totalPoints;

            const numDarkStores = parseInt(numDarkStoresClusteringInput.value) || 10; 
            if (numDarkStoresDisplay) numDarkStoresDisplay.textContent = numDarkStores;


            const numHotspotCenters = 4; 
            const pointsPerHotspot = hotspotCount > 0 && numHotspotCenters > 0 ? Math.floor(hotspotCount / numHotspotCenters) : 0;
            
            let allOrderPoints = []; 
            
            generateUniformPointInPolygon(backgroundCount, chandigarhGeoJsonPolygon).forEach(p => { 
                allOrderPoints.push({ ...p, type: 'background' });
            });
            
            if (pointsPerHotspot > 0) {
                const hotspotCenterCoords = generateUniformPointInPolygon(numHotspotCenters, chandigarhGeoJsonPolygon); 
                hotspotCenterCoords.forEach(center => { 
                    generateGaussianPointsInPolygon(center, 0.008, pointsPerHotspot, chandigarhGeoJsonPolygon).forEach(p => { 
                        allOrderPoints.push({ ...p, type: 'hotspot' });
                    });
                });
            }
            
            let currentGenerated = allOrderPoints.length;
            if (currentGenerated < totalPoints && (totalPoints - currentGenerated) > 0) {
                generateUniformPointInPolygon(totalPoints - currentGenerated, chandigarhGeoJsonPolygon).forEach(p => { 
                       allOrderPoints.push({ ...p, type: 'background' }); 
                });
            }
            allOrderPoints = allOrderPoints.slice(0, totalPoints);
            
            const kMeansDarkStoreLocations = kMeansClustering(allOrderPoints, numDarkStores); 
            
            const darkStoreIcon = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
                iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
            
            const dcPointsForVoronoi = []; 
            kMeansDarkStoreLocations.forEach((store, index) => { 
                if (store && typeof store.lat === 'number' && typeof store.lng === 'number') {
                    L.marker([store.lat, store.lng], { icon: darkStoreIcon })
                        .bindPopup(`<b>Dark Store ${index + 1}</b><br>Location: ${store.lat.toFixed(4)}, ${store.lng.toFixed(4)}`).addTo(darkStoreMarkersLayerGroup);
                    dcPointsForVoronoi.push([store.lng, store.lat]); 
                    globalClusteredDarkStores.push({id: index, name: `Dark Store ${index + 1}`, lat: store.lat, lng: store.lng }); 
                }
            });
            populateDarkStoreSelector(); 

            const clusterData = Array(numDarkStores).fill(null).map(() => ({ orders: [], distances: [] }));
            let totalOverallDistance = 0;
            let totalAssignedOrders = 0;
            let allDistances = [];


            allOrderPoints.forEach(p => { 
                let minDist = Infinity;
                let closestDsIndex = -1;
                kMeansDarkStoreLocations.forEach((ds, index) => { 
                     if (ds && typeof ds.lat === 'number' && typeof ds.lng === 'number') { 
                        const dist = getDistanceSimple(p, ds); 
                        if (dist < minDist) {
                            minDist = dist;
                            closestDsIndex = index;
                        }
                    }
                });
                if (closestDsIndex !== -1 && kMeansDarkStoreLocations[closestDsIndex]) { 
                    const distKm = getDistanceKm(p, kMeansDarkStoreLocations[closestDsIndex]); 
                    clusterData[closestDsIndex].orders.push(p);
                    clusterData[closestDsIndex].distances.push(distKm); 
                    allDistances.push(distKm);
                    totalOverallDistance += distKm;
                    totalAssignedOrders++;
                    L.polyline([[p.lat, p.lng], [kMeansDarkStoreLocations[closestDsIndex].lat, kMeansDarkStoreLocations[closestDsIndex].lng]], 
                               {color: '#94a3b8', opacity: 0.4, weight: 1}).addTo(orderToStoreLinesLayerGroup);
                }

                const color = p.type === 'hotspot' ? '#a855f7' : '#3b82f6'; 
                L.circleMarker([p.lat, p.lng], { radius: p.type === 'hotspot' ? 3.5 : 2.5, color: color, fillColor: color, fillOpacity: 0.8, weight:1 }) 
                    .bindPopup(`Type: ${p.type}<br>Coords: ${p.lat.toFixed(4)}, ${p.lng.toFixed(4)}`).addTo(demandPointsLayerGroup);
            });

            if(clusteringStatsDiv) {
                clusteringStatsDiv.innerHTML = ''; 
                clusterData.forEach((data, index) => {
                    const numOrders = data.orders.length;
                    const avgDist = numOrders > 0 ? (data.distances.reduce((a, b) => a + b, 0) / numOrders) : 0;
                    const maxDist = numOrders > 0 ? Math.max(...data.distances) : 0;
                    const minDist = numOrders > 0 ? Math.min(...data.distances) : 0;
                    const stdDevDist = numOrders > 1 ? calculateStdDev(data.distances, avgDist) : 0;
                    
                    const statEl = document.createElement('div');
                    statEl.className = 'stat-card p-4 text-left';
                    statEl.innerHTML = `
                        <h5 class="font-semibold text-lg text-blue-700 mb-2">Dark Store ${index + 1}</h5>
                        <p><strong class="text-slate-600">Orders:</strong> ${numOrders}</p>
                        <p><strong class="text-slate-600">Avg. Dist:</strong> ${avgDist.toFixed(2)} km</p>
                        <p><strong class="text-slate-600">Min Dist:</strong> ${minDist.toFixed(2)} km</p>
                        <p><strong class="text-slate-600">Max Dist:</strong> ${maxDist.toFixed(2)} km</p>
                        <p><strong class="text-slate-600">Std. Dev. Dist:</strong> ${stdDevDist.toFixed(2)} km</p>
                    `;
                    clusteringStatsDiv.appendChild(statEl);
                });
                 if (clusterData.every(d => d.orders.length === 0) && allOrderPoints.length > 0) {
                     clusteringStatsDiv.innerHTML = '<p class="italic text-slate-500 md:col-span-2 lg:col-span-3 text-center">Could not assign orders to clusters. Check K-Means output.</p>';
                 } else if (allOrderPoints.length === 0) {
                       clusteringStatsDiv.innerHTML = '<p class="italic text-slate-500 md:col-span-2 lg:col-span-3 text-center">No orders generated for clustering.</p>';
                 }
            }
            const overallAvgClusterDistEl = document.getElementById('overallAvgClusterDistance');
            const overallMinClusterDistEl = document.getElementById('overallMinClusterDistance');
            const overallMaxClusterDistEl = document.getElementById('overallMaxClusterDistance');
            const overallStdDevClusterDistEl = document.getElementById('overallStdDevClusterDistance');

            const overallAvg = totalAssignedOrders > 0 ? (totalOverallDistance / totalAssignedOrders) : NaN;
            if(overallAvgClusterDistEl) overallAvgClusterDistEl.textContent = isNaN(overallAvg) ? "N/A" : overallAvg.toFixed(2) + " km";
            if(overallMinClusterDistEl) overallMinClusterDistEl.textContent = allDistances.length > 0 ? Math.min(...allDistances).toFixed(2) + " km" : "N/A";
            if(overallMaxClusterDistEl) overallMaxClusterDistEl.textContent = allDistances.length > 0 ? Math.max(...allDistances).toFixed(2) + " km" : "N/A";
            const overallStdDev = allDistances.length > 1 && !isNaN(overallAvg) ? calculateStdDev(allDistances, overallAvg) : NaN;
            if(overallStdDevClusterDistEl) overallStdDevClusterDistEl.textContent = isNaN(overallStdDev) ? "N/A" : overallStdDev.toFixed(2) + " km";


            if (dcPointsForVoronoi.length >= 3 && typeof d3 !== 'undefined' && d3.Delaunay) { 
                try {
                    const delaunay = d3.Delaunay.from(dcPointsForVoronoi); 
                    const voronoiBounds = [minLng - 0.1, minLat - 0.1, maxLng + 0.1, maxLat + 0.1]; 
                    const voronoi = delaunay.voronoi(voronoiBounds);

                    for (let i = 0; i < dcPointsForVoronoi.length; i++) {
                        const cellPolygonGeoJson = voronoi.cellPolygon(i); 
                        if (cellPolygonGeoJson && cellPolygonGeoJson.length > 0) {
                            const cellLeafletCoords = cellPolygonGeoJson.map(p => [p[1], p[0]]); 
                            L.polygon(cellLeafletCoords, {
                                className: 'voronoi-cell-path', 
                                color: "#0ea5e9", 
                                weight: 1.5,     
                                fill: false,   
                                fillOpacity: 0  
                            }).addTo(voronoiLayerGroup);
                        }
                    }
                } catch(e) {
                    console.error("Error during Voronoi generation:", e, dcPointsForVoronoi);
                }
            }
            cityBoundaryOutlineLayer.addTo(clusteringMapInstance); 

            if (showOrderConnectionsToggle && showOrderConnectionsToggle.checked) {
                if (!clusteringMapInstance.hasLayer(orderToStoreLinesLayerGroup)) {
                     orderToStoreLinesLayerGroup.addTo(clusteringMapInstance);
                }
            } else {
                if (clusteringMapInstance.hasLayer(orderToStoreLinesLayerGroup)) {
                    clusteringMapInstance.removeLayer(orderToStoreLinesLayerGroup);
                }
            }
        }
        
        // kMeans expects points as {lat, lng}, returns centroids as {lat, lng}
        function kMeansClustering(points,k,maxIterations=20){
            if(points.length === 0) return [];
            if(points.length<k){ k = Math.max(1, points.length); } 
            
            let centroids = [];
            if (k > 0) {
                 centroids = points.slice(0,k).map(p=>({...p})); 
                 if(points.length > k && k > 0){ 
                    centroids=[];
                    const step=Math.floor(points.length/k);
                    for(let i=0;i<k;i++) centroids.push({...points[i*step]});
                }
            } else {
                return [];
            }

            let assignments=[];
            for(let iter=0;iter<maxIterations;iter++){
                assignments=points.map(point=>{
                    let minDist=Infinity,closestCentroidIndex=0;
                    centroids.forEach((centroid,index)=>{
                        if(!centroid || typeof centroid.lat !== 'number' || typeof centroid.lng !== 'number'){ return;} 
                        const dist=getDistanceSimple(point,centroid); 
                        if(dist<minDist){minDist=dist;closestCentroidIndex=index;}
                    });
                    return closestCentroidIndex;
                });
                const newCentroids=[];
                for(let i=0;i<k;i++){
                    const clusterPoints=points.filter((_,index)=>assignments[index]===i);
                    if(clusterPoints.length>0){
                        const sumLat=clusterPoints.reduce((sum,p)=>sum+p.lat,0);
                        const sumLng=clusterPoints.reduce((sum,p)=>sum+p.lng,0); 
                        newCentroids.push({lat:sumLat/clusterPoints.length,lng:sumLng/clusterPoints.length}); 
                    }else{ 
                        let fallbackPtArray = generateUniformPointInPolygon(1, chandigarhGeoJsonPolygon); 
                        let fallbackCentroid = centroids[i] || (fallbackPtArray.length > 0 ? fallbackPtArray[0] : {lat: chandigarhCenter.lat, lng: chandigarhCenter.lng}); 
                        newCentroids.push(fallbackCentroid);
                    }
                } 
                let converged=true;
                if(newCentroids.length !== centroids.length){ converged=false;} 
                else {
                    for(let i=0;i<k;i++){
                        if(!centroids[i]||!newCentroids[i]|| typeof centroids[i].lat !== 'number' || typeof newCentroids[i].lat !== 'number' ||getDistanceSimple(centroids[i],newCentroids[i])>0.0001){converged=false;break;}
                    }
                }
                centroids=newCentroids;
                if(converged)break;
            }
            return centroids;
        }

        // Expects p1, p2 as {lat, lng}
        function getDistanceSimple(p1,p2){
            if(!p1||!p2 || typeof p1.lat !== 'number' || typeof p1.lng !== 'number' || typeof p2.lat !== 'number' || typeof p2.lng !== 'number') return Infinity; 
            const dLat=p1.lat-p2.lat,dLng=p1.lng-p2.lng; 
            return Math.sqrt(dLat*dLat+dLng*dLng);
        }


        // --- Simulation Logic ---
        let simulationMapInstance; 
        let darkStoreMarkerSim; 
        const darkStoreLocationSim = { lat: 30.7333, lng: 76.7794 }; 
        let agents = [];
        let orders = [];
        let agentMarkers = {}; 
        let orderMarkers = {}; 
        let simulationInterval;
        let simulationTime = 0;
        let orderIdCounter = 0;
        let agentIdCounter = 1; 
        let simulationRunning = false;
        let allDeliveryTimes = [];
        let sumOrderWaitTimes = 0;
        let countAssignedOrdersStat = 0;
        
        const SIMULATION_STEP_INTERVAL_MS = 1000; 
        const MINUTES_PER_SIMULATION_STEP = 1; 
        
        let FIXED_HANDLING_TIME_PER_ORDER = 5; 
        let MIN_AGENT_SPEED = 20;
        let MAX_AGENT_SPEED = 30;
        let ORDER_LOCATION_SPREAD_FACTOR = 0.05; 
        let NUM_WAYPOINTS = 1; 
        let MANUAL_TRAFFIC_FACTOR = 1.0;
        let CURRENT_DYNAMIC_TRAFFIC_FACTOR = 1.0; // Used if dynamic traffic is on

        let totalOrdersGeneratedStat = 0;
        let totalOrdersDeliveredStat = 0;
        let sumDeliveryTimesStat = 0;
        let totalAgentTravelTimeStat = 0;
        let totalAgentHandlingTimeStat = 0;


        const simTimeDisplay = document.getElementById('simTimeDisplay');
        const agentStatusList = document.getElementById('agentStatusList');
        const pendingOrdersList = document.getElementById('pendingOrdersList');
        const simulationLog = document.getElementById('simulationLog');
        const startSimBtn = document.getElementById('startSimBtn');
        const pauseSimBtn = document.getElementById('pauseSimBtn');
        const resetSimBtn = document.getElementById('resetSimBtn');
        const numAgentsSlider = document.getElementById('numAgentsSlider');
        const orderFrequencySlider = document.getElementById('orderFrequencySlider');
        
        const orderGenerationProbabilities = { 1: 0.05, 2: 0.1, 3: 0.2, 4: 0.3, 5: 0.4 }; 
        let currentOrderGenerationProbability = orderGenerationProbabilities[3]; 
        const orderSpreadFactors = {1: 0.02, 2: 0.035, 3: 0.05, 4: 0.065, 5: 0.08};
        const DYNAMIC_TRAFFIC_UPDATE_INTERVAL = 15; // Update dynamic traffic every 15 sim minutes


        function createAgentIcon(agentId, isBusy) {
            const colorClass = isBusy ? 'agent-busy' : 'agent-available';
            return L.divIcon({
                html: `<div class="marker-icon-base ${colorClass}">${agentId}</div>`,
                className: '', 
                iconSize: [28, 28], iconAnchor: [14, 14], popupAnchor: [0, -14] });
        }
        function createOrderIcon(orderId, status) { 
            let colorClass = 'order-pending';
            if (status === 'assigned_to_agent_going_to_store' || status === 'at_store_with_agent' || status === 'out_for_delivery') {
                colorClass = 'order-assigned';
            }
            return L.divIcon({
                html: `<div class="marker-icon-base ${colorClass}">${orderId}</div>`,
                className: '',
                iconSize: [28, 28], iconAnchor: [14, 14], popupAnchor: [0, -14] });
        }
        
        const storeIconSim = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png', shadowSize: [41, 41]});

        function initSimulationMap() { 
            if (simulationMapInstance) { simulationMapInstance.remove(); simulationMapInstance = null; }
            simulationMapInstance = L.map('simulationMap').setView([darkStoreLocationSim.lat, darkStoreLocationSim.lng], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(simulationMapInstance);
            darkStoreMarkerSim = L.marker([darkStoreLocationSim.lat, darkStoreLocationSim.lng], {icon: storeIconSim})
                .addTo(simulationMapInstance)
                .bindPopup('<b>Dark Store Chandigarh (Simulation)</b><br>Central Hub')
                .openPopup();
            initializeSimulationState(); 
        }
        
        function initializeSimulationState() {
            simulationTime = 0; orderIdCounter = 0; agentIdCounter = 1; 
            agents.forEach(agent => { if (agent.routePolyline) agent.routePolyline.remove(); });
            agents = []; orders = [];
            
            Object.values(agentMarkers).forEach(m => m.remove()); agentMarkers = {};
            Object.values(orderMarkers).forEach(m => m.remove()); orderMarkers = {};

            totalOrdersGeneratedStat = 0;
            totalOrdersDeliveredStat = 0;
            sumDeliveryTimesStat = 0;
            allDeliveryTimes = [];
            sumOrderWaitTimes = 0;
            countAssignedOrdersStat = 0;
            totalAgentTravelTimeStat = 0;
            totalAgentHandlingTimeStat = 0;

            updateSimulationStatsDisplay();

            const numberOfAgentsToCreate = numAgentsSlider ? parseInt(numAgentsSlider.value) : 5;
            MIN_AGENT_SPEED = document.getElementById('agentMinSpeedSlider') ? parseInt(document.getElementById('agentMinSpeedSlider').value) : 20;
            MAX_AGENT_SPEED = document.getElementById('agentMaxSpeedSlider') ? parseInt(document.getElementById('agentMaxSpeedSlider').value) : 30;
            if (MIN_AGENT_SPEED > MAX_AGENT_SPEED) MIN_AGENT_SPEED = MAX_AGENT_SPEED; 
            FIXED_HANDLING_TIME_PER_ORDER = document.getElementById('handlingTimeSlider') ? parseInt(document.getElementById('handlingTimeSlider').value) : 5;
            ORDER_LOCATION_SPREAD_FACTOR = document.getElementById('orderSpreadSlider') ? orderSpreadFactors[document.getElementById('orderSpreadSlider').value] : orderSpreadFactors[3];
            NUM_WAYPOINTS = document.getElementById('routeWaypointsSelect') ? parseInt(document.getElementById('routeWaypointsSelect').value) : 1;
            MANUAL_TRAFFIC_FACTOR = document.getElementById('manualTrafficControl') ? parseFloat(document.getElementById('manualTrafficControl').value) : 1.0;
            CURRENT_DYNAMIC_TRAFFIC_FACTOR = MANUAL_TRAFFIC_FACTOR; // Initialize with manual setting
            updateTrafficStatusDisplay(CURRENT_DYNAMIC_TRAFFIC_FACTOR);


            for (let i = 0; i < numberOfAgentsToCreate; i++) { createAgent(); }
            
            currentOrderGenerationProbability = orderFrequencySlider ? orderGenerationProbabilities[orderFrequencySlider.value] : orderGenerationProbabilities[3];

            updateAgentStatusList(); updatePendingOrdersList(); updateSimTimeDisplay();
            logMessageSim(`Simulation state initialized/reset. Using ${numberOfAgentsToCreate} agents.`, 'SYSTEM');
            if(startSimBtn) startSimBtn.disabled = false;
            if(pauseSimBtn) pauseSimBtn.disabled = true;
            [numAgentsSlider, orderFrequencySlider, document.getElementById('agentMinSpeedSlider'), document.getElementById('agentMaxSpeedSlider'), document.getElementById('handlingTimeSlider'), document.getElementById('orderSpreadSlider'), document.getElementById('routeWaypointsSelect'), document.getElementById('manualTrafficControl'), document.getElementById('enableDynamicTraffic'), document.getElementById('orderGenerationProfileSelect'), document.getElementById('defaultOrderFocusRadiusSlider')].forEach(el => {
                if (el) el.disabled = false;
            });
        }

        function createAgent() {
            const agentId = agentIdCounter++; 
            const speedRange = MAX_AGENT_SPEED - MIN_AGENT_SPEED;
            const agentSpeed = speedRange >= 0 ? MIN_AGENT_SPEED + Math.random() * speedRange : MIN_AGENT_SPEED;
            const newAgent = {
                id: agentId, 
                location: { lat: darkStoreLocationSim.lat + (Math.random() - 0.5) * 0.002, lng: darkStoreLocationSim.lng + (Math.random() - 0.5) * 0.002 }, 
                speedKmph: agentSpeed, 
                status: 'available', 
                assignedOrderId: null, 
                routePath: [], currentLegIndex: 0, legProgress: 0, timeSpentAtStore: 0, 
                deliveriesMade: 0,
                totalTime: 0, // For utilization
                busyTime: 0,  // For utilization
                routePolyline: null
            };
            agents.push(newAgent);
            if (simulationMapInstance) {
                agentMarkers[agentId] = L.marker([newAgent.location.lat, newAgent.location.lng], {icon: createAgentIcon(agentId, false)})
                    .addTo(simulationMapInstance)
                    .bindPopup(`<b>Agent ${newAgent.id}</b><br>Status: ${newAgent.status}<br>Deliveries: ${newAgent.deliveriesMade}<br>Speed: ${agentSpeed.toFixed(1)} km/h`);
            }
        }

        function generateOrderSim() { 
            const orderId = orderIdCounter++;
            totalOrdersGeneratedStat++; 
            let newOrderLocation;
            const selectedProfileId = document.getElementById('orderGenerationProfileSelect').value;
            
            if (selectedProfileId.startsWith('custom_')) {
                const profileName = selectedProfileId.substring('custom_'.length);
                const customProfile = customDemandProfiles.find(p => p.name === profileName);
                if (customProfile && customProfile.zones && customProfile.zones.length > 0) {
                    const activeZones = customProfile.zones.filter(zone => {
                        const startTime = zone.startTime !== undefined ? zone.startTime : 0; 
                        const endTime = zone.endTime !== undefined ? zone.endTime : Infinity; 
                        return simulationTime >= startTime && simulationTime <= endTime;
                    });

                    if (activeZones.length > 0) {
                        let totalOrderWeight = activeZones.reduce((sum, zone) => sum + (zone.maxOrders > 0 ? (zone.minOrders + zone.maxOrders) / 2 : 1), 0); // Use avg as weight
                        if (totalOrderWeight === 0) totalOrderWeight = activeZones.length;


                        let randomPick = Math.random() * totalOrderWeight;
                        let selectedZone = null;
                        for (const zone of activeZones) {
                            const weight = (zone.minOrders + zone.maxOrders)/2 > 0 ? (zone.minOrders + zone.maxOrders)/2 : (totalOrderWeight === activeZones.length ? 1 : 0); 
                            if (randomPick < weight) {
                                selectedZone = zone;
                                break;
                            }
                            randomPick -= weight;
                        }
                        if (!selectedZone && activeZones.length > 0) selectedZone = activeZones[Math.floor(Math.random() * activeZones.length)]; 

                        if (selectedZone) {
                            if (selectedZone.type === 'uniform') {
                                const uniformPoints = generateUniformPointInPolygon(1, chandigarhGeoJsonPolygon);
                                newOrderLocation = uniformPoints.length > 0 ? uniformPoints[0] : { ...darkStoreLocationSim };
                                logMessageSim(`Generated Order ${orderId} (Profile: ${profileName}, Zone: Uniform) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
                            } else if (selectedZone.type === 'hotspot') {
                                const hotspotCenter = {lat: selectedZone.centerLat, lng: selectedZone.centerLng};
                                const spreadKm = selectedZone.spreadKm;
                                const spreadDeg = spreadKm / 111; 
                                
                                let attempts = 0;
                                do {
                                    newOrderLocation = { 
                                        lat: hotspotCenter.lat + (Math.random() - 0.5) * 2 * spreadDeg, 
                                        lng: hotspotCenter.lng + (Math.random() - 0.5) * 2 * spreadDeg 
                                    };
                                    attempts++;
                                } while (!isPointInPolygon([newOrderLocation.lng, newOrderLocation.lat], chandigarhGeoJsonPolygon) && attempts < 100);
                                if (attempts >= 100 && !isPointInPolygon([newOrderLocation.lng, newOrderLocation.lat], chandigarhGeoJsonPolygon)) {
                                    newOrderLocation = { ...hotspotCenter }; 
                                }
                                logMessageSim(`Generated Order ${orderId} (Profile: ${profileName}, Zone: Hotspot near ${hotspotCenter.lat.toFixed(3)},${hotspotCenter.lng.toFixed(3)}) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
                            } else if (selectedZone.type === 'sector') {
                                if (selectedZone.selectedSectors && selectedZone.selectedSectors.length > 0) {
                                    const randomSectorName = selectedZone.selectedSectors[Math.floor(Math.random() * selectedZone.selectedSectors.length)];
                                    const sectorData = chandigarhSectors.find(s => s.name === randomSectorName);
                                    if (sectorData) {
                                        const sectorCenter = {lat: sectorData.lat, lng: sectorData.lng};
                                        const sectorSpreadDeg = 0.005; 
                                        let attempts = 0;
                                        do {
                                            newOrderLocation = { 
                                                lat: sectorCenter.lat + (Math.random() - 0.5) * 2 * sectorSpreadDeg, 
                                                lng: sectorCenter.lng + (Math.random() - 0.5) * 2 * sectorSpreadDeg 
                                            };
                                            attempts++;
                                        } while (!isPointInPolygon([newOrderLocation.lng, newOrderLocation.lat], chandigarhGeoJsonPolygon) && attempts < 50);
                                        if (attempts >= 50 && !isPointInPolygon([newOrderLocation.lng, newOrderLocation.lat], chandigarhGeoJsonPolygon)) {
                                            newOrderLocation = { ...sectorCenter }; 
                                        }
                                        logMessageSim(`Generated Order ${orderId} (Profile: ${profileName}, Zone: Sector-Based - ${randomSectorName}) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
                                    } else {
                                        newOrderLocation = { ...darkStoreLocationSim }; 
                                        logMessageSim(`Generated Order ${orderId} (Profile: ${profileName}, Zone: Sector ${randomSectorName} data not found, fallback) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
                                    }
                                } else {
                                     newOrderLocation = { ...darkStoreLocationSim }; 
                                     logMessageSim(`Generated Order ${orderId} (Profile: ${profileName}, Zone: Sector-Based - No sectors chosen, fallback) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
                                }
                            } else if (selectedZone.type === 'route') {
                                // Placeholder: Generate uniformly within bounding box of route points
                                if (selectedZone.routePoints && selectedZone.routePoints.length >= 2) {
                                    let minRouteLat = Infinity, maxRouteLat = -Infinity, minRouteLng = Infinity, maxRouteLng = -Infinity;
                                    selectedZone.routePoints.forEach(p => {
                                        if (p[0] < minRouteLat) minRouteLat = p[0];
                                        if (p[0] > maxRouteLat) maxRouteLat = p[0];
                                        if (p[1] < minRouteLng) minRouteLng = p[1];
                                        if (p[1] > maxRouteLng) maxRouteLng = p[1];
                                    });
                                    let attempts = 0;
                                    do {
                                        newOrderLocation = {
                                            lat: minRouteLat + Math.random() * (maxRouteLat - minRouteLat),
                                            lng: minRouteLng + Math.random() * (maxRouteLng - minRouteLng)
                                        };
                                        attempts++;
                                    } while(!isPointInPolygon([newOrderLocation.lng, newOrderLocation.lat], chandigarhGeoJsonPolygon) && attempts < 50);
                                    if (attempts >= 50 && !isPointInPolygon([newOrderLocation.lng, newOrderLocation.lat], chandigarhGeoJsonPolygon)){
                                        newOrderLocation = generateUniformPointInPolygon(1, chandigarhGeoJsonPolygon)[0] || {...darkStoreLocationSim};
                                    }
                                } else {
                                     newOrderLocation = generateUniformPointInPolygon(1, chandigarhGeoJsonPolygon)[0] || {...darkStoreLocationSim};
                                }
                                logMessageSim(`Generated Order ${orderId} (Profile: ${profileName}, Zone: Route-Based - Placeholder) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
                            } else {
                                 newOrderLocation = { ...darkStoreLocationSim }; 
                                 logMessageSim(`Generated Order ${orderId} (Profile: ${profileName}, Zone: Unknown type, fallback) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
                            }
                        } else { 
                             totalOrdersGeneratedStat--; return; 
                        }
                    } else { 
                        totalOrdersGeneratedStat--; return; 
                    }
                } else {
                     newOrderLocation = { ...darkStoreLocationSim }; 
                     logMessageSim(`Generated Order ${orderId} (Profile: ${profileName} not found, fallback) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
                }

            } else if (selectedProfileId === 'default_focused') {
                const focusRadiusKm = parseFloat(document.getElementById('defaultOrderFocusRadiusSlider').value);
                const focusRadiusDeg = focusRadiusKm / 111;
                let attempts = 0;
                do {
                    newOrderLocation = { 
                        lat: darkStoreLocationSim.lat + (Math.random() - 0.5) * 2 * focusRadiusDeg, 
                        lng: darkStoreLocationSim.lng + (Math.random() - 0.5) * 2 * focusRadiusDeg 
                    };
                    attempts++;
                } while (!isPointInPolygon([newOrderLocation.lng, newOrderLocation.lat], chandigarhGeoJsonPolygon) && attempts < 100);
                if (attempts >= 100 && !isPointInPolygon([newOrderLocation.lng, newOrderLocation.lat], chandigarhGeoJsonPolygon)) {
                    newOrderLocation = { ...darkStoreLocationSim };
                }
                logMessageSim(`Generated Order ${orderId} (Profile: Default Focused) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
            } else { // Default: Uniform City-Wide
                const uniformPoints = generateUniformPointInPolygon(1, chandigarhGeoJsonPolygon);
                newOrderLocation = uniformPoints.length > 0 ? uniformPoints[0] : { ...darkStoreLocationSim };
                logMessageSim(`Generated Order ${orderId} (Profile: Default Uniform) at [${newOrderLocation.lat.toFixed(4)}, ${newOrderLocation.lng.toFixed(4)}].`, 'ORDER');
            }


            const newOrder = { 
                id: orderId, 
                location: newOrderLocation,
                status: 'pending', assignedAgentId: null, etaMinutes: null, 
                timePlaced: simulationTime,
                assignmentTime: null 
            };
            orders.push(newOrder);
            if (simulationMapInstance) {
                orderMarkers[orderId] = L.marker([newOrder.location.lat, newOrder.location.lng], {icon: createOrderIcon(orderId, 'pending')})
                    .addTo(simulationMapInstance)
                    .bindPopup(`<b>Order ${newOrder.id}</b><br>Status: ${newOrder.status}<br>Placed at: T+${newOrder.timePlaced} min`);
            }
        }
        
        // Expects coords1, coords2 as {lat, lng}
        function getDistanceKm(coords1, coords2) { 
            if(!coords1 || !coords2 || typeof coords1.lat !== 'number' || typeof coords1.lng !== 'number' || typeof coords2.lat !== 'number' || typeof coords2.lng !== 'number' ) return Infinity;
            const latLng1 = L.latLng(coords1.lat, coords1.lng);
            const latLng2 = L.latLng(coords2.lat, coords2.lng);
            return latLng1.distanceTo(latLng2) / 1000; 
        }
        
        // Expects start, end as {lat, lng}, returns waypoints as [{lat, lng}]
        function generateWaypoints(start, end, numWaypoints) { 
            const waypoints = [];
             if(!start || !end || typeof start.lat !== 'number' || typeof start.lng !== 'number' || typeof end.lat !== 'number' || typeof end.lng !== 'number' ) return waypoints;
            const legDistance = getDistanceKm(start, end);
            if (legDistance < 0.2 || numWaypoints === 0) return waypoints; 

            for (let i = 1; i <= numWaypoints; i++) {
                const fraction = i / (numWaypoints + 1);
                const midLat = start.lat + (end.lat - start.lat) * fraction;
                const midLng = start.lng + (end.lng - start.lng) * fraction; 
                
                const maxOffsetDegrees = Math.min(0.005, legDistance * 0.0001); 
                const offsetX = (Math.random() - 0.5) * 2 * maxOffsetDegrees; 
                const offsetY = (Math.random() - 0.5) * 2 * maxOffsetDegrees;

                waypoints.push({ lat: midLat + offsetY, lng: midLng + offsetX }); 
            }
            return waypoints;
        }

        function calculateETA(agent, orderLocation) { 
            const effectiveTrafficFactor = document.getElementById('enableDynamicTraffic').checked ? CURRENT_DYNAMIC_TRAFFIC_FACTOR : MANUAL_TRAFFIC_FACTOR;
            const agentToStoreDistKm = getDistanceKm(agent.location, darkStoreLocationSim); 
            const storeToOrderDistKm = getDistanceKm(darkStoreLocationSim, orderLocation);
            const totalTravelDistKm = agentToStoreDistKm + storeToOrderDistKm; 
            const travelTimeHours = totalTravelDistKm / (agent.speedKmph * effectiveTrafficFactor); 
            const travelTimeMinutes = travelTimeHours * 60;
            return travelTimeMinutes + FIXED_HANDLING_TIME_PER_ORDER;
        }

        function assignOrdersSim() { 
            let unassignedOrderExists = false;
            orders.filter(o => o.status === 'pending').forEach(order => { 
                unassignedOrderExists = true;
                let bestAgent = null;
                let shortestETA = Infinity;
                agents.filter(a => a.status === 'available').forEach(agent => { 
                    const eta = calculateETA(agent, order.location); 
                    if (eta < shortestETA) { shortestETA = eta; bestAgent = agent; }
                });
                if (bestAgent) {
                    order.status = 'assigned_to_agent_going_to_store'; 
                    order.assignedAgentId = bestAgent.id; 
                    order.etaMinutes = shortestETA;
                    order.assignmentTime = simulationTime;
                    sumOrderWaitTimes += (order.assignmentTime - order.timePlaced);
                    countAssignedOrdersStat++;

                    bestAgent.assignedOrderId = order.id; 
                    bestAgent.status = 'to_store';
                    logMessageSim(`Agent ${bestAgent.id} assigned Order ${order.id}. ETA: ${shortestETA.toFixed(1)} min. Wait time: ${(order.assignmentTime - order.timePlaced)} min.`, 'AGENT');
                    
                    const waypointsToStore = generateWaypoints(bestAgent.location, darkStoreLocationSim, NUM_WAYPOINTS); 
                    bestAgent.routePath = [bestAgent.location, ...waypointsToStore, darkStoreLocationSim]; 
                    bestAgent.currentLegIndex = 0; bestAgent.legProgress = 0;
                    logMessageSim(`Agent ${bestAgent.id} en route to Dark Store for Order ${order.id}.`, 'AGENT_MOVE');

                    if (bestAgent.routePolyline) bestAgent.routePolyline.remove(); 
                    if(simulationMapInstance && bestAgent.routePath.length > 0) {bestAgent.routePolyline = L.polyline(bestAgent.routePath.map(p => [p.lat, p.lng]), {color: '#0ea5e9', weight: 3, opacity: 0.7, dashArray: '5, 5'}).addTo(simulationMapInstance);}
                    if (orderMarkers[order.id]) { orderMarkers[order.id].setIcon(createOrderIcon(order.id, 'assigned')).setPopupContent(`<b>Order ${order.id}</b><br>Status: Assigned (Agent ${bestAgent.id})<br>ETA: ${order.etaMinutes.toFixed(1)} min`); }
                    if (agentMarkers[bestAgent.id]) { agentMarkers[bestAgent.id].setIcon(createAgentIcon(bestAgent.id, true)).setPopupContent(`<b>Agent ${bestAgent.id}</b><br>Status: To Store (Order ${order.id})<br>Deliveries: ${bestAgent.deliveriesMade}<br>Speed: ${bestAgent.speedKmph.toFixed(1)} km/h`); }
                } else {
                    if(!order.noAgentLogged) { 
                        logMessageSim(`No available agent for Order ${order.id}. Order remains pending.`, 'SYSTEM');
                        order.noAgentLogged = true;
                    }
                }
            });
        }
        
        function updateAgentsMovementAndStatus() {
            agents.forEach(agent => {
                agent.totalTime += MINUTES_PER_SIMULATION_STEP;
                if(agent.status !== 'available') {
                    agent.busyTime += MINUTES_PER_SIMULATION_STEP;
                }

                if (agent.status === 'available') return;

                const effectiveTrafficFactor = document.getElementById('enableDynamicTraffic').checked ? CURRENT_DYNAMIC_TRAFFIC_FACTOR : MANUAL_TRAFFIC_FACTOR;

                if (agent.status === 'at_store') {
                    agent.timeSpentAtStore += MINUTES_PER_SIMULATION_STEP;
                    totalAgentHandlingTimeStat += MINUTES_PER_SIMULATION_STEP; 
                    logMessageSim(`Agent ${agent.id} handling Order ${agent.assignedOrderId} at store. (${agent.timeSpentAtStore}/${FIXED_HANDLING_TIME_PER_ORDER} min)`, 'AGENT_DETAIL');
                    
                    if (agent.timeSpentAtStore >= FIXED_HANDLING_TIME_PER_ORDER) {
                        const order = orders.find(o => o.id === agent.assignedOrderId);
                        if (order && order.location) { 
                            agent.status = 'to_customer';
                            const waypointsToCustomer = generateWaypoints(darkStoreLocationSim, order.location, NUM_WAYPOINTS);
                            agent.routePath = [darkStoreLocationSim, ...waypointsToCustomer, order.location]; 
                            order.status = 'out_for_delivery';
                            logMessageSim(`Agent ${agent.id} LEFT store with Order ${order.id}. En route to customer.`, 'AGENT_MOVE');
                            
                            agent.currentLegIndex = 0; agent.legProgress = 0;
                            if (agent.routePolyline) agent.routePolyline.remove();
                            if(simulationMapInstance && agent.routePath.length > 1) { agent.routePolyline = L.polyline(agent.routePath.map(p => [p.lat, p.lng]), {color: '#16a34a', weight: 3, opacity: 0.8}).addTo(simulationMapInstance); }
                            if (agentMarkers[agent.id]) { agentMarkers[agent.id].setPopupContent(`<b>Agent ${agent.id}</b><br>Status: To Customer (Order ${agent.assignedOrderId})<br>Deliveries: ${agent.deliveriesMade}<br>Speed: ${agent.speedKmph.toFixed(1)} km/h`); }
                        } else { 
                            logMessageSim(`Order ${agent.assignedOrderId} not found for Agent ${agent.id} at store. Agent becoming available.`, 'ERROR');
                            agent.status = 'available'; 
                            agent.assignedOrderId = null;
                            if (agent.routePolyline) { agent.routePolyline.remove(); agent.routePolyline = null; }
                        }
                    }
                    return; 
                }

                if (agent.status === 'to_store' || agent.status === 'to_customer') {
                    totalAgentTravelTimeStat += MINUTES_PER_SIMULATION_STEP; 
                }

                if (!agent.routePath || agent.routePath.length < 2 || agent.currentLegIndex >= agent.routePath.length - 1) return; 
                
                const startPoint = agent.routePath[agent.currentLegIndex]; 
                const endPoint = agent.routePath[agent.currentLegIndex + 1]; 

                if(!startPoint || !endPoint || typeof startPoint.lat !== 'number' || typeof endPoint.lat !== 'number') { 
                    logMessageSim(`Invalid route for Agent ${agent.id}. Path: ${JSON.stringify(agent.routePath)}, Index: ${agent.currentLegIndex}. Resetting agent.`, 'ERROR');
                    agent.status = 'available'; agent.assignedOrderId = null; if(agent.routePolyline) agent.routePolyline.remove(); return;
                }

                const legDistanceKm = getDistanceKm(startPoint, endPoint);

                if (legDistanceKm < 0.001) { 
                    agent.legProgress = 1;
                } else { 
                    const distanceToCoverThisStepKm = (agent.speedKmph * effectiveTrafficFactor / 60) * MINUTES_PER_SIMULATION_STEP;
                    agent.legProgress += (distanceToCoverThisStepKm / legDistanceKm);
                }

                if (agent.legProgress >= 1) {
                    agent.legProgress = 0; 
                    agent.location = {...endPoint}; 
                    agent.currentLegIndex++; 
                    
                    if (agent.status === 'to_store' && agent.currentLegIndex === agent.routePath.length -1 ) { 
                        agent.status = 'at_store';
                        agent.timeSpentAtStore = 0; 
                        logMessageSim(`Agent ${agent.id} ARRIVED at Dark Store for Order ${agent.assignedOrderId}.`, 'AGENT');
                        const order = orders.find(o => o.id === agent.assignedOrderId);
                        if(order) order.status = 'at_store_with_agent';
                        if (agentMarkers[agent.id]) { agentMarkers[agent.id].setPopupContent(`<b>Agent ${agent.id}</b><br>Status: At Store (Order ${agent.assignedOrderId})<br>Deliveries: ${agent.deliveriesMade}<br>Speed: ${agent.speedKmph.toFixed(1)} km/h`); }
                    } 
                    else if (agent.status === 'to_customer' && agent.currentLegIndex === agent.routePath.length -1) { 
                        const deliveredOrder = orders.find(o => o.id === agent.assignedOrderId);
                        if (deliveredOrder && deliveredOrder.location.lat === agent.location.lat && deliveredOrder.location.lng === agent.location.lng) {
                            deliveredOrder.status = 'delivered';
                            totalOrdersDeliveredStat++; 
                            const deliveryDuration = simulationTime - deliveredOrder.timePlaced;
                            sumDeliveryTimesStat += deliveryDuration; 
                            allDeliveryTimes.push(deliveryDuration);
                            logMessageSim(`Agent ${agent.id} DELIVERED Order ${agent.assignedOrderId}. Delivery time: ${deliveryDuration.toFixed(1)} min.`, 'ORDER');
                            if (orderMarkers[agent.assignedOrderId]) { orderMarkers[agent.assignedOrderId].remove(); delete orderMarkers[agent.assignedOrderId]; }
                            agent.deliveriesMade++;
                            agent.status = 'available';
                            logMessageSim(`Agent ${agent.id} now AVAILABLE. Total deliveries: ${agent.deliveriesMade}.`, 'AGENT');
                            if (agent.routePolyline) { agent.routePolyline.remove(); agent.routePolyline = null; }
                            agent.assignedOrderId = null; agent.routePath = []; agent.currentLegIndex = 0;
                            if (agentMarkers[agent.id]) { agentMarkers[agent.id].setIcon(createAgentIcon(agent.id, false)).setPopupContent(`<b>Agent ${agent.id}</b><br>Status: Available<br>Deliveries: ${agent.deliveriesMade}<br>Speed: ${agent.speedKmph.toFixed(1)} km/h`); }
                        } else {
                            logMessageSim(`Agent ${agent.id} arrived at customer location for Order ${agent.assignedOrderId}, but location mismatch or order not found. Agent becoming available.`, 'ERROR');
                            agent.status = 'available'; agent.assignedOrderId = null; agent.routePath = []; agent.currentLegIndex = 0;
                        }
                    }
                } else { 
                    const currentLegStart = agent.routePath[agent.currentLegIndex];
                    const currentLegEnd = agent.routePath[agent.currentLegIndex + 1];
                    if(currentLegStart && currentLegEnd && typeof currentLegStart.lat === 'number' && typeof currentLegEnd.lat === 'number') {
                        const newLat = currentLegStart.lat + (currentLegEnd.lat - currentLegStart.lat) * agent.legProgress;
                        const newLng = currentLegStart.lng + (currentLegEnd.lng - currentLegStart.lng) * agent.legProgress; 
                        agent.location = { lat: newLat, lng: newLng }; 
                    }
                }
                if (agentMarkers[agent.id] && simulationMapInstance && agent.location && typeof agent.location.lat === 'number') { agentMarkers[agent.id].setLatLng([agent.location.lat, agent.location.lng]); }
            });
        }
        
        function simulationStep() {
            if (!simulationRunning) return;
            simulationTime += MINUTES_PER_SIMULATION_STEP;
            updateSimTimeDisplay();

            if (document.getElementById('enableDynamicTraffic').checked && (simulationTime % DYNAMIC_TRAFFIC_UPDATE_INTERVAL === 0 || simulationTime === MINUTES_PER_SIMULATION_STEP)) {
                const factors = [0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3];
                CURRENT_DYNAMIC_TRAFFIC_FACTOR = factors[Math.floor(Math.random() * factors.length)];
                logMessageSim(`Dynamic traffic updated. Factor: ${CURRENT_DYNAMIC_TRAFFIC_FACTOR.toFixed(1)}x`, "TRAFFIC");
                updateTrafficStatusDisplay(CURRENT_DYNAMIC_TRAFFIC_FACTOR);
            }
            
            if (Math.random() < currentOrderGenerationProbability) { generateOrderSim(); }
            updateAgentsMovementAndStatus(); assignOrdersSim(); 
            updateAgentStatusList(); updatePendingOrdersList();
            updateSimulationStatsDisplay();
            orders = orders.filter(o => o.status !== 'delivered');
        }

        function logMessageSim(message, type = 'INFO') {
            if(!simulationLog) return;
            const logEntry = document.createElement('p');
            logEntry.classList.add('log-message');
            let typeClass = 'log-info'; // Default
            let prefix = `[${type.toUpperCase()}]`;

            switch(type.toUpperCase()) {
                case 'AGENT': typeClass = 'log-agent'; break;
                case 'AGENT_MOVE': typeClass = 'log-agent'; prefix = '[AGENT_MOVE]'; break; 
                case 'AGENT_DETAIL': typeClass = 'log-agent'; prefix = '[AGENT_HANDLING]'; break; 
                case 'ORDER': typeClass = 'log-order'; break;
                case 'SYSTEM': typeClass = 'log-system'; break;
                case 'ERROR': typeClass = 'log-error'; break;
                case 'WARNING': typeClass = 'log-system'; break; 
                case 'TRAFFIC': typeClass = 'log-system'; break;
            }
            logEntry.classList.add(typeClass);
            logEntry.innerHTML = `<em>${prefix} [T:${simulationTime}]</em> ${message}`;
            simulationLog.appendChild(logEntry);
            simulationLog.scrollTop = simulationLog.scrollHeight;
        }
        function logMessageOpt(message, type = 'INFO', logElement) {
            if(!logElement) return;
            const logEntry = document.createElement('p');
            logEntry.classList.add('log-message');
            let typeClass = 'log-info'; 
            let prefix = `[${type.toUpperCase()}]`;

            switch(type.toUpperCase()) {
                case 'ITERATION': typeClass = 'log-info'; break;
                case 'STATS': typeClass = 'log-order'; prefix = '[STATS]'; break;
                case 'SYSTEM': typeClass = 'log-system'; break;
                case 'SYSTEM_BOLD': typeClass = 'log-system-bold'; prefix = '[SYS]'; break; // For final summary
                case 'ERROR': typeClass = 'log-error'; break;
                case 'WARNING': typeClass = 'log-system'; break;
                case 'ORDER_OPT': typeClass = 'log-order'; prefix = '[ORDER_ITER]'; break;
            }
            logEntry.classList.add(typeClass);
            logEntry.innerHTML = `<em>${prefix}</em> ${message}`;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
        }


        function updateSimTimeDisplay() { if(simTimeDisplay) simTimeDisplay.textContent = simulationTime; }

        function updateTrafficStatusDisplay(factor) {
            const statusEl = document.getElementById('currentTrafficStatus');
            if (!statusEl) return;
            let condition = "Normal";
            if (factor < 0.9) condition = "Heavy";
            else if (factor > 1.1) condition = "Light";
            statusEl.textContent = `Traffic: ${condition} (${factor.toFixed(1)}x)`;
        }


        function updateAgentStatusList() {
            if(!agentStatusList) return;
            agentStatusList.innerHTML = '';
            if (agents.length === 0) { agentStatusList.innerHTML = '<p class="text-slate-500 italic">No agents yet.</p>'; return; }
            agents.forEach(agent => {
                const agentDiv = document.createElement('div');
                let statusText = `Agent ${agent.id}: ${agent.status.replace(/_/g, ' ')}`;
                if (agent.assignedOrderId !== null) { statusText += ` (Order: ${agent.assignedOrderId})`; }
                if (agent.status === 'at_store') { statusText += ` (${agent.timeSpentAtStore}/${FIXED_HANDLING_TIME_PER_ORDER} min)`; }
                statusText += ` | Delivered: ${agent.deliveriesMade}`;
                const utilization = agent.totalTime > 0 ? (agent.busyTime / agent.totalTime * 100).toFixed(1) : 0;
                statusText += ` | Util: ${utilization}%`;
                agentDiv.className = `p-1.5 rounded-md text-xs ${agent.status === 'available' ? 'bg-blue-100 text-blue-700 border border-blue-200' : 'bg-orange-100 text-orange-700 border border-orange-200'}`;
                agentDiv.textContent = statusText;
                agentStatusList.appendChild(agentDiv);
            });
        }
        
        function updatePendingOrdersList() {
            if(!pendingOrdersList) return;
            pendingOrdersList.innerHTML = '';
            const activeOrders = orders.filter(o => o.status !== 'delivered' && o.status !== 'pending_removal'); 
             if (activeOrders.length === 0) { pendingOrdersList.innerHTML = '<p class="text-slate-500 italic">No active orders.</p>'; return; }
            activeOrders.forEach(order => {
                const orderDiv = document.createElement('div');
                let orderText = `Order ${order.id}: ${order.status.replace(/_/g, ' ')}`;
                if (order.assignedAgentId !== null) { orderText += ` (Agent ${order.assignedAgentId}, ETA ${order.etaMinutes ? order.etaMinutes.toFixed(1) : 'N/A'} min)`; }
                else { orderText += ` (Placed: T+${order.timePlaced} min)`}
                orderDiv.className = `p-1.5 rounded-md text-xs ${order.status === 'pending' ? 'bg-green-100 text-green-700 border border-green-200' : 'bg-yellow-100 text-yellow-700 border border-yellow-200'}`;
                orderDiv.textContent = orderText;
                pendingOrdersList.appendChild(orderDiv);
            });
        }

        function calculateStdDev(arr, mean) {
            if (!arr || arr.length < 2) return 0;
            const n = arr.length;
            return Math.sqrt(arr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / (n -1) ); // Sample std dev
        }

        function updateSimulationStatsDisplay() {
            if(document.getElementById('statsTotalOrdersGenerated')) document.getElementById('statsTotalOrdersGenerated').textContent = totalOrdersGeneratedStat;
            if(document.getElementById('statsTotalOrdersDelivered')) document.getElementById('statsTotalOrdersDelivered').textContent = totalOrdersDeliveredStat;
            
            const avgDeliveryTime = totalOrdersDeliveredStat > 0 ? (sumDeliveryTimesStat / totalOrdersDeliveredStat) : NaN;
            if(document.getElementById('statsAvgDeliveryTime')) document.getElementById('statsAvgDeliveryTime').textContent = isNaN(avgDeliveryTime) ? "N/A" : avgDeliveryTime.toFixed(1) + " min";

            if(document.getElementById('statsMinDeliveryTime')) document.getElementById('statsMinDeliveryTime').textContent = allDeliveryTimes.length > 0 ? Math.min(...allDeliveryTimes).toFixed(1) + " min" : "N/A";
            if(document.getElementById('statsMaxDeliveryTime')) document.getElementById('statsMaxDeliveryTime').textContent = allDeliveryTimes.length > 0 ? Math.max(...allDeliveryTimes).toFixed(1) + " min" : "N/A";
            
            const stdDevDelTime = calculateStdDev(allDeliveryTimes, avgDeliveryTime);
            if(document.getElementById('statsStdDevDeliveryTime')) document.getElementById('statsStdDevDeliveryTime').textContent = (allDeliveryTimes.length > 1 && !isNaN(stdDevDelTime)) ? stdDevDelTime.toFixed(1) + " min" : "N/A";

            const avgOrderWaitTime = countAssignedOrdersStat > 0 ? (sumOrderWaitTimes / countAssignedOrdersStat).toFixed(1) : "N/A";
            if(document.getElementById('statsAvgOrderWaitTime')) document.getElementById('statsAvgOrderWaitTime').textContent = avgOrderWaitTime + (avgOrderWaitTime !== "N/A" ? " min" : "");

            let totalAgentPossibleTime = 0;
            let totalAgentActualBusyTime = 0;
            agents.forEach(agent => {
                totalAgentPossibleTime += agent.totalTime;
                totalAgentActualBusyTime += agent.busyTime;
            });
            const avgAgentUtilization = totalAgentPossibleTime > 0 ? (totalAgentActualBusyTime / totalAgentPossibleTime * 100).toFixed(1) : "N/A";
            if(document.getElementById('statsAvgAgentUtilization')) document.getElementById('statsAvgAgentUtilization').textContent = avgAgentUtilization + (avgAgentUtilization !== "N/A" ? "%" : "");


            if(document.getElementById('statsTotalAgentTravelTime')) document.getElementById('statsTotalAgentTravelTime').textContent = totalAgentTravelTimeStat + " min";
            if(document.getElementById('statsTotalAgentHandlingTime')) document.getElementById('statsTotalAgentHandlingTime').textContent = totalAgentHandlingTimeStat + " min";
            if(document.getElementById('statsTotalSimTime')) document.getElementById('statsTotalSimTime').textContent = simulationTime + " min";
        }


        if(startSimBtn) {
            startSimBtn.addEventListener('click', () => {
                if (!simulationRunning) { 
                    if (!simulationMapInstance) {
                        initSimulationMap(); 
                    } else if (simulationTime > 0 && pauseSimBtn && !pauseSimBtn.disabled) { 
                        logMessageSim("Simulation resumed.", 'SYSTEM');
                    } else { 
                         initializeSimulationState(); 
                    }
                    
                    simulationRunning = true;
                    
                    simulationInterval = setInterval(simulationStep, SIMULATION_STEP_INTERVAL_MS); 
                    if (simulationTime === 0) logMessageSim("Simulation started.", 'SYSTEM'); 
                    startSimBtn.disabled = true; 
                    if(pauseSimBtn) pauseSimBtn.disabled = false;
                    [numAgentsSlider, orderFrequencySlider, document.getElementById('agentMinSpeedSlider'), document.getElementById('agentMaxSpeedSlider'), document.getElementById('handlingTimeSlider'), document.getElementById('orderSpreadSlider'), document.getElementById('routeWaypointsSelect'), document.getElementById('manualTrafficControl'), document.getElementById('enableDynamicTraffic'), document.getElementById('orderGenerationProfileSelect'), document.getElementById('defaultOrderFocusRadiusSlider')].forEach(el => {
                        if (el) el.disabled = true;
                    });
                }
            });
        }

        if(pauseSimBtn) {
            pauseSimBtn.addEventListener('click', () => {
                if (simulationRunning) {
                    simulationRunning = false; clearInterval(simulationInterval);
                    logMessageSim("Simulation paused.", 'SYSTEM');
                    if(startSimBtn) startSimBtn.disabled = false; 
                    pauseSimBtn.disabled = true;
                }
            });
        }
        
        if(resetSimBtn) {
            resetSimBtn.addEventListener('click', () => {
                simulationRunning = false; clearInterval(simulationInterval);
                if(simulationLog) simulationLog.innerHTML = ''; 
                if (simulationMapInstance) { initializeSimulationState(); } 
                else { initSimulationMap(); } 
                logMessageSim("Simulation reset by user.", 'SYSTEM');
            });
        }
        
       if(pauseSimBtn) pauseSimBtn.disabled = true;

        // --- Workforce Optimization Logic ---
        let optimizationMapInstance;
        let optDarkStoreMarkersLayer;
        let optOrderMarkersLayer; 
        let optOrderHeatmapLayer = null; 
        let allOptimizationIterationsData = []; // To store data for table and charts


        function initOptimizationMapVisualisation() {
            if (optimizationMapInstance) { optimizationMapInstance.remove(); optimizationMapInstance = null;}
            optimizationMapInstance = L.map('optimizationMapViz').setView([chandigarhCenter.lat, chandigarhCenter.lng], 12);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(optimizationMapInstance);
            optDarkStoreMarkersLayer = L.layerGroup().addTo(optimizationMapInstance);
            optOrderMarkersLayer = L.layerGroup().addTo(optimizationMapInstance); 
            if (optOrderHeatmapLayer && optimizationMapInstance.hasLayer(optOrderHeatmapLayer)) { 
                optimizationMapInstance.removeLayer(optOrderHeatmapLayer);
                optOrderHeatmapLayer = null; 
            }
             // Add Chandigarh boundary to this map for context
            L.polygon(chandigarhLeafletCoords, { color: '#334155', weight: 3, fill: false, dashArray: '5, 5', interactive: false }).addTo(optimizationMapInstance);
            document.getElementById('optimizationMapContainer').classList.remove('hidden'); 
       }

       function populateDarkStoreSelector() {
            const selector = document.getElementById('optSelectDarkStore');
            const runButton = document.getElementById('runOptimizationBtn');
            if (!selector || !runButton) return;

            const currentVal = selector.value;
            selector.innerHTML = ''; 

            if (globalClusteredDarkStores && globalClusteredDarkStores.length > 0) {
                globalClusteredDarkStores.forEach(store => {
                    const option = document.createElement('option');
                    option.value = store.id; 
                    option.textContent = `${store.name} (Lat: ${store.lat.toFixed(3)}, Lng: ${store.lng.toFixed(3)})`;
                    if (store.id.toString() === currentVal) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
                selector.disabled = false;
                runButton.disabled = false;
            } else {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "-- Run Clustering First to Select a Store --";
                selector.appendChild(option);
                selector.disabled = true;
                runButton.disabled = true;
            }
        }


        async function runWorkforceOptimization() {
            const targetDeliveryTimeInput = document.getElementById('optTargetDeliveryTime');
            const ordersPerIterationInput = document.getElementById('optOrdersPerIteration'); 
            const maxSimTimePerIterationInput = document.getElementById('optMaxSimTimePerIteration');
            const minAgentsInput = document.getElementById('optMinAgents');
            const maxAgentsInput = document.getElementById('optMaxAgents');
            const darkStoreSelector = document.getElementById('optSelectDarkStore'); 
            const resultsContainer = document.getElementById('optimizationResultsContainer');
            const optLog = document.getElementById('optimizationLog');
            const runOptimizationButton = document.getElementById('runOptimizationBtn');
            const optimizationMapContainer = document.getElementById('optimizationMapContainer');
            const comparisonTableContainer = document.getElementById('optimizationComparisonContainer');
            const chartsContainer = document.getElementById('optimizationChartsContainer');
            
            allOptimizationIterationsData = []; // Clear previous iteration data
            comparisonTableContainer.classList.add('hidden'); // Hide table initially
            chartsContainer.classList.add('hidden'); // Hide charts initially


            if (!targetDeliveryTimeInput || !ordersPerIterationInput || !maxSimTimePerIterationInput ||
                !minAgentsInput || !maxAgentsInput || !darkStoreSelector ||
                !resultsContainer || !optLog || !runOptimizationButton || !optimizationMapContainer ) {
                console.error("One or more optimization UI elements are missing.");
                 if(optLog) logMessageOpt("Error: Critical UI elements for optimization are missing. Cannot proceed.", 'ERROR', optLog);
                if(runOptimizationButton) runOptimizationButton.disabled = false; runOptimizationButton.textContent = "Run Workforce Optimization";
                return;
            }
            
            const selectedDarkStoreId = parseInt(darkStoreSelector.value);
            const selectedDarkStore = globalClusteredDarkStores.find(ds => ds.id === selectedDarkStoreId);

            if (isNaN(selectedDarkStoreId) || !selectedDarkStore) {
                logMessageOpt("Error: Please select a valid dark store. Run clustering first if list is empty.", 'ERROR', optLog);
                runOptimizationButton.disabled = false; runOptimizationButton.textContent = "Run Workforce Optimization";
                return;
            }

            let minAgentsToTest = parseInt(minAgentsInput.value);
            let maxAgentsToTest = parseInt(maxAgentsInput.value);

            if (isNaN(minAgentsToTest) || minAgentsToTest < 1) {
                minAgentsToTest = 1;
                logMessageOpt(`Warning: Invalid Min Agents. Defaulting to ${minAgentsToTest}.`, 'WARNING', optLog);
                minAgentsInput.value = minAgentsToTest;
            }
            if (isNaN(maxAgentsToTest) || maxAgentsToTest < minAgentsToTest || maxAgentsToTest > 25) { 
                maxAgentsToTest = Math.min(Math.max(minAgentsToTest, 10), 25); 
                logMessageOpt(`Warning: Invalid Max Agents. Defaulting to ${maxAgentsToTest}.`, 'WARNING', optLog);
                maxAgentsInput.value = maxAgentsToTest;
            }


            runOptimizationButton.disabled = true;
            runOptimizationButton.textContent = "Optimizing...";
            optLog.innerHTML = ""; 
            logMessageOpt(`Starting workforce optimization using Dark Store: ${selectedDarkStore.name}...`, 'SYSTEM', optLog);
            
            const baseMinAgentSpeed = document.getElementById('agentMinSpeedSlider') ? parseInt(document.getElementById('agentMinSpeedSlider').value) : 20;
            const baseMaxAgentSpeed = document.getElementById('agentMaxSpeedSlider') ? parseInt(document.getElementById('agentMaxSpeedSlider').value) : 30;
            const baseHandlingTime = document.getElementById('handlingTimeSlider') ? parseInt(document.getElementById('handlingTimeSlider').value) : 5;
            const baseTrafficFactor = document.getElementById('manualTrafficControl') ? parseFloat(document.getElementById('manualTrafficControl').value) : 1.0; 
            const baseOrderFrequencySliderValue = document.getElementById('orderFrequencySlider') ? document.getElementById('orderFrequencySlider').value : '3';
            const baseOrderGenProb = orderGenerationProbabilities[baseOrderFrequencySliderValue]; 
            const baseOrderSpreadSliderValue = document.getElementById('orderSpreadSlider') ? document.getElementById('orderSpreadSlider').value : '3';
            const baseOrderSpread = orderSpreadFactors[baseOrderSpreadSliderValue]; 
            const baseNumWaypoints = document.getElementById('routeWaypointsSelect') ? parseInt(document.getElementById('routeWaypointsSelect').value) : 1;


            logMessageOpt(`Using parameters: Agent Speed(${baseMinAgentSpeed}-${baseMaxAgentSpeed}km/h), Handling(${baseHandlingTime}min), Traffic(${baseTrafficFactor.toFixed(1)}x), Order Arrival Prob(${baseOrderGenProb}) for each step.`, 'SYSTEM', optLog);
            logMessageOpt(`Testing agents from ${minAgentsToTest} to ${maxAgentsToTest}.`, 'SYSTEM', optLog);


            resultsContainer.classList.remove('hidden');
            optimizationMapContainer.classList.remove('hidden'); 
            if (!optimizationMapInstance) initOptimizationMapVisualisation();
            else { 
                 if(optDarkStoreMarkersLayer) optDarkStoreMarkersLayer.clearLayers();
                 if(optOrderMarkersLayer) optOrderMarkersLayer.clearLayers();
                 if(optOrderHeatmapLayer && optimizationMapInstance.hasLayer(optOrderHeatmapLayer)) {
                    optimizationMapInstance.removeLayer(optOrderHeatmapLayer);
                    optOrderHeatmapLayer = null;
                 }
            }


            document.getElementById('optResultAgents').textContent = "Calculating...";
            document.getElementById('optResultAvgTime').textContent = "Calculating...";
            document.getElementById('optResultMinDelTime').textContent = "Calculating...";
            document.getElementById('optResultMaxDelTime').textContent = "Calculating...";
            document.getElementById('optResultStdDevDelTime').textContent = "Calculating...";
            document.getElementById('optResultAvgUtilization').textContent = "Calculating...";
            document.getElementById('optResultAvgWaitTime').textContent = "Calculating...";
            document.getElementById('optResultUndelivered').textContent = "Calculating...";
            document.getElementById('optDarkStoreDistances').innerHTML = "";
            document.getElementById('optOverallAvgDistance').textContent = "Calculating...";

            const targetAvgTime = parseInt(targetDeliveryTimeInput.value);
            const numOrdersToSimCap = parseInt(ordersPerIterationInput.value); 
            const maxSimTime = parseInt(maxSimTimePerIterationInput.value);

            document.getElementById('optResultTargetTime').textContent = targetAvgTime + " min";

            let bestAgentCount = -1;
            let bestAvgDeliveryTime = Infinity;
            let closestDiff = Infinity;
            let bestDarkStoreDistanceStats = null;
            let bestIterationStats = { deliveryTimes: [] }; 
            let bestIterationOrderLocations = []; 
            
            const iterationDarkStores = [selectedDarkStore]; 

            for (let currentNumAgents = minAgentsToTest; currentNumAgents <= maxAgentsToTest; currentNumAgents++) {
                logMessageOpt(`Testing with ${currentNumAgents} agent(s)...`, 'ITERATION', optLog);
                optLog.scrollTop = optLog.scrollHeight;

                let iterationSimTime = 0;
                let iterationOrders = [];
                let iterationAgents = [];
                let iterationOrderIdCounter = 0;
                let iterationTotalDelivered = 0;
                let iterationSumDeliveryTimes = 0;
                let currentIterationDeliveryTimes = [];
                let iterationSumOrderWaitTimes = 0;
                let iterationNumOrdersAssigned = 0;
                let ordersGeneratedThisIteration = 0; 
                
                for (let i = 0; i < currentNumAgents; i++) {
                    const speedRange = baseMaxAgentSpeed - baseMinAgentSpeed;
                    const agentSpeed = speedRange >= 0 ? baseMinAgentSpeed + Math.random() * speedRange : baseMinAgentSpeed; 
                    iterationAgents.push({
                        id: i, location: {...selectedDarkStore}, 
                        speedKmph: agentSpeed, status: 'available', assignedOrderId: null,
                        routePath: [], currentLegIndex: 0, legProgress: 0, timeSpentAtStore: 0,
                        totalTime: 0, busyTime: 0 
                    });
                }
                
                while(iterationSimTime < maxSimTime) { 
                    iterationSimTime += MINUTES_PER_SIMULATION_STEP;
                    iterationAgents.forEach(agent => agent.totalTime += MINUTES_PER_SIMULATION_STEP);

                    if (ordersGeneratedThisIteration < numOrdersToSimCap && Math.random() < baseOrderGenProb) {
                        const orderId = iterationOrderIdCounter++;
                        ordersGeneratedThisIteration++;
                        const orderLocationPointArray = generateUniformPointInPolygon(1, chandigarhGeoJsonPolygon);
                        const orderLocation = orderLocationPointArray.length > 0 ? orderLocationPointArray[0] : { lat: selectedDarkStore.lat, lng: selectedDarkStore.lng };

                        iterationOrders.push({ 
                            id: orderId, location: orderLocation, 
                            status: 'pending', assignedAgentId: null, timePlaced: iterationSimTime, 
                            assignedDarkStoreId: selectedDarkStore.id, 
                            assignmentTime: null
                        });
                        logMessageOpt(`[T:${iterationSimTime}] Generated Order ${orderId} (Total: ${ordersGeneratedThisIteration}/${numOrdersToSimCap})`, 'ORDER_OPT', optLog);
                    }
                    
                    iterationOrders.filter(o => o.status === 'pending' && o.assignedDarkStoreId === selectedDarkStore.id).forEach(order => {
                        let bestAgent = null;
                        let shortestETASim = Infinity;
                        iterationAgents.filter(a => a.status === 'available').forEach(agent => {
                            const agentToStoreDistKm = 0; 
                            const storeToOrderDistKm = getDistanceKm(selectedDarkStore, order.location);
                            const travelTimeHours = (agentToStoreDistKm + storeToOrderDistKm) / (agent.speedKmph * baseTrafficFactor);
                            const eta = (travelTimeHours * 60) + baseHandlingTime;
                            if (eta < shortestETASim) { shortestETASim = eta; bestAgent = agent; }
                        });

                        if (bestAgent) {
                            order.status = 'assigned_to_agent_going_to_store'; 
                            order.assignedAgentId = bestAgent.id;
                            order.assignmentTime = iterationSimTime; 
                            iterationSumOrderWaitTimes += (order.assignmentTime - order.timePlaced); 
                            iterationNumOrdersAssigned++;
                            logMessageOpt(`[T:${iterationSimTime}] Order ${order.id} assigned to Agent ${bestAgent.id}. Wait: ${(order.assignmentTime - order.timePlaced)}m.`, 'ORDER_OPT', optLog);


                            bestAgent.assignedOrderId = order.id; 
                            bestAgent.status = 'at_store'; 
                            bestAgent.location = {...selectedDarkStore}; 
                            bestAgent.routePath = [selectedDarkStore, order.location]; 
                            bestAgent.currentLegIndex = 0; 
                            bestAgent.legProgress = 0; 
                            bestAgent.timeSpentAtStore = 0; 
                        }
                    });

                    iterationAgents.forEach(agent => {
                        if (agent.status === 'available') return;
                        
                        agent.busyTime += MINUTES_PER_SIMULATION_STEP; 

                        if (agent.status === 'at_store') {
                            agent.timeSpentAtStore += MINUTES_PER_SIMULATION_STEP;
                            if (agent.timeSpentAtStore >= baseHandlingTime) {
                                const orderForAgent = iterationOrders.find(o => o.id === agent.assignedOrderId);
                                if (orderForAgent && orderForAgent.location) {
                                    agent.status = 'to_customer';
                                    agent.routePath = [agent.location, orderForAgent.location]; 
                                    agent.currentLegIndex = 0; 
                                    agent.legProgress = 0;
                                } else { 
                                    agent.status = 'available'; agent.assignedOrderId = null; agent.routePath = [];
                                }
                            }
                            return;
                        }
                        
                        if (agent.status === 'to_customer') {
                            if (!agent.routePath || agent.routePath.length !== 2 || agent.currentLegIndex !== 0) {
                                agent.status = 'available'; agent.assignedOrderId = null; agent.routePath = [];
                                return;
                            }

                            const startPoint = agent.routePath[0]; 
                            const endPoint = agent.routePath[1];   
                            
                            if(!startPoint || !endPoint || typeof startPoint.lat !== 'number' || typeof endPoint.lat !== 'number') { 
                                 agent.status = 'available'; agent.assignedOrderId = null; agent.routePath = []; return;
                            }

                            const legDistanceKm = getDistanceKm(startPoint, endPoint);
                            if (legDistanceKm < 0.001) { agent.legProgress = 1; } 
                            else {
                                const distCovered = (agent.speedKmph * baseTrafficFactor / 60) * MINUTES_PER_SIMULATION_STEP;
                                agent.legProgress += (distCovered / legDistanceKm);
                            }

                            if (agent.legProgress >= 1) {
                                agent.legProgress = 0; 
                                agent.location = {...endPoint}; 
                                
                                const deliveredOrder = iterationOrders.find(o => o.id === agent.assignedOrderId);
                                if (deliveredOrder) {
                                    deliveredOrder.status = 'delivered';
                                    iterationTotalDelivered++;
                                    const deliveryDuration = iterationSimTime - deliveredOrder.timePlaced;
                                    iterationSumDeliveryTimes += deliveryDuration;
                                    currentIterationDeliveryTimes.push(deliveryDuration);
                                    logMessageOpt(`[T:${iterationSimTime}] Order ${deliveredOrder.id} delivered by Agent ${agent.id}. Delivery time: ${deliveryDuration.toFixed(1)} min.`, 'ORDER_OPT', optLog);
                                }
                                agent.status = 'available'; agent.assignedOrderId = null; agent.routePath = [];
                            } else { 
                                 agent.location = {
                                    lat: startPoint.lat + (endPoint.lat - startPoint.lat) * agent.legProgress,
                                    lng: startPoint.lng + (endPoint.lng - startPoint.lng) * agent.legProgress
                                };
                            }
                        }
                    });
                } 

                const currentAvgDeliveryTime = iterationTotalDelivered > 0 ? (iterationSumDeliveryTimes / iterationTotalDelivered) : Infinity;
                const totalAgentActualBusyTime = iterationAgents.reduce((sum,a) => sum + a.busyTime, 0);
                const totalPossibleAgentTime = currentNumAgents * iterationSimTime; 
                const currentAvgAgentUtilization = totalPossibleAgentTime > 0 ? (totalAgentActualBusyTime / totalPossibleAgentTime) * 100 : 0;
                const currentAvgOrderWaitTime = iterationNumOrdersAssigned > 0 ? (iterationSumOrderWaitTimes / iterationNumOrdersAssigned) : Infinity;
                const iterationUndeliveredOrders = ordersGeneratedThisIteration - iterationTotalDelivered;

                let iterMinDelTime = currentIterationDeliveryTimes.length > 0 ? Math.min(...currentIterationDeliveryTimes).toFixed(1) : "N/A";
                let iterMaxDelTime = currentIterationDeliveryTimes.length > 0 ? Math.max(...currentIterationDeliveryTimes).toFixed(1) : "N/A";
                let iterStdDevDelTime = "N/A";
                if (currentIterationDeliveryTimes.length > 1 && currentAvgDeliveryTime !== Infinity) {
                     iterStdDevDelTime = calculateStdDev(currentIterationDeliveryTimes, currentAvgDeliveryTime).toFixed(1);
                }
                
                allOptimizationIterationsData.push({
                    agents: currentNumAgents,
                    generatedOrders: ordersGeneratedThisIteration,
                    deliveredOrders: iterationTotalDelivered,
                    avgDeliveryTime: currentAvgDeliveryTime === Infinity ? null : parseFloat(currentAvgDeliveryTime.toFixed(1)),
                    minDeliveryTime: iterMinDelTime === "N/A" ? null : parseFloat(iterMinDelTime),
                    maxDeliveryTime: iterMaxDelTime === "N/A" ? null : parseFloat(iterMaxDelTime),
                    stdDevDeliveryTime: iterStdDevDelTime === "N/A" ? null : parseFloat(iterStdDevDelTime),
                    avgAgentUtilization: parseFloat(currentAvgAgentUtilization.toFixed(1)) || 0,
                    avgOrderWaitTime: currentAvgOrderWaitTime === Infinity ? null : parseFloat(currentAvgOrderWaitTime.toFixed(1)),
                    undeliveredOrders: iterationUndeliveredOrders
                });


                if (iterationSimTime >= maxSimTime && iterationTotalDelivered < ordersGeneratedThisIteration) {
                     logMessageOpt(`For ${currentNumAgents} agents: Timed out at ${maxSimTime} mins. Generated: ${ordersGeneratedThisIteration}, Delivered: ${iterationTotalDelivered}.`, 'SYSTEM', optLog);
                } else if (iterationTotalDelivered >= ordersGeneratedThisIteration && ordersGeneratedThisIteration > 0) {
                     logMessageOpt(`For ${currentNumAgents} agents: All ${ordersGeneratedThisIteration} generated orders processed/delivered by T+${iterationSimTime}.`, 'INFO', optLog);
                } else if (ordersGeneratedThisIteration === 0) {
                     logMessageOpt(`For ${currentNumAgents} agents: No orders generated within ${maxSimTime} mins.`, 'WARNING', optLog);
                }


                logMessageOpt(`&nbsp;&nbsp;Stats: AvgDel(${currentAvgDeliveryTime === Infinity ? 'N/A' : currentAvgDeliveryTime.toFixed(1)}m) MinDel(${iterMinDelTime}m) MaxDel(${iterMaxDelTime}m) StdDevDel(${iterStdDevDelTime}m) Util(${currentAvgAgentUtilization.toFixed(1)}%) Wait(${currentAvgOrderWaitTime === Infinity ? 'N/A' : currentAvgOrderWaitTime.toFixed(1)}m) Undel(${iterationUndeliveredOrders})`, 'STATS', optLog);
                
                const deliveryThreshold = ordersGeneratedThisIteration * 0.8; 
                if (iterationTotalDelivered >= deliveryThreshold && iterationTotalDelivered > 0 ) { 
                    const diff = Math.abs(currentAvgDeliveryTime - targetAvgTime);
                    if (diff < closestDiff || (diff === closestDiff && currentAvgDeliveryTime < bestAvgDeliveryTime) ) {
                        closestDiff = diff;
                        bestAvgDeliveryTime = currentAvgDeliveryTime;
                        bestAgentCount = currentNumAgents;
                        bestIterationStats = {
                            avgDeliveryTime: bestAvgDeliveryTime,
                            minDeliveryTime: parseFloat(iterMinDelTime) || null,
                            maxDeliveryTime: parseFloat(iterMaxDelTime) || null,
                            stdDevDeliveryTime: parseFloat(iterStdDevDelTime) || null,
                            avgUtilization: currentAvgAgentUtilization,
                            avgWaitTime: currentAvgOrderWaitTime,
                            undelivered: iterationUndeliveredOrders,
                            deliveryTimes: [...currentIterationDeliveryTimes] 
                        };
                        bestIterationOrderLocations = iterationOrders.filter(o=>o.status === 'delivered').map(o => ({lat: o.location.lat, lng: o.location.lng, count: 1})); 

                        let ordersForThisStore = 0;
                        let totalDistanceForThisStore = 0;
                        iterationOrders.filter(o => o.assignedDarkStoreId === selectedDarkStore.id && o.status === 'delivered').forEach(order => {
                            ordersForThisStore++;
                            totalDistanceForThisStore += getDistanceKm(order.location, selectedDarkStore);
                        });

                        bestDarkStoreDistanceStats = {
                            locations: [selectedDarkStore], 
                            perStore: [{ 
                                id: selectedDarkStore.id,
                                name: selectedDarkStore.name,
                                avgDist: ordersForThisStore > 0 ? (totalDistanceForThisStore / ordersForThisStore).toFixed(2) : "N/A",
                                orderCount: ordersForThisStore
                            }],
                            overallAvg: ordersForThisStore > 0 ? (totalDistanceForThisStore / ordersForThisStore).toFixed(2) : "N/A"
                        };
                    }
                }
                 await new Promise(resolve => setTimeout(resolve, 5)); 
            } 

            document.getElementById('optResultAgents').textContent = bestAgentCount !== -1 ? bestAgentCount : "Not Found";
            document.getElementById('optResultAvgTime').textContent = bestIterationStats.avgDeliveryTime !== undefined && bestIterationStats.avgDeliveryTime !== Infinity ? bestIterationStats.avgDeliveryTime.toFixed(1) + " min" : "N/A";
            document.getElementById('optResultMinDelTime').textContent = bestIterationStats.minDeliveryTime !== null && !isNaN(bestIterationStats.minDeliveryTime) ? bestIterationStats.minDeliveryTime.toFixed(1) + " min" : "N/A";
            document.getElementById('optResultMaxDelTime').textContent = bestIterationStats.maxDeliveryTime !== null && !isNaN(bestIterationStats.maxDeliveryTime) ? bestIterationStats.maxDeliveryTime.toFixed(1) + " min" : "N/A";
            document.getElementById('optResultStdDevDelTime').textContent = bestIterationStats.stdDevDeliveryTime !== null && !isNaN(bestIterationStats.stdDevDeliveryTime) ? bestIterationStats.stdDevDeliveryTime.toFixed(1) + " min" : "N/A";
            document.getElementById('optResultAvgUtilization').textContent = bestIterationStats.avgUtilization !== undefined ? bestIterationStats.avgUtilization.toFixed(1) + "%" : "N/A";
            document.getElementById('optResultAvgWaitTime').textContent = bestIterationStats.avgWaitTime !== undefined && bestIterationStats.avgWaitTime !== Infinity ? bestIterationStats.avgWaitTime.toFixed(1) + " min" : "N/A";
            document.getElementById('optResultUndelivered').textContent = bestIterationStats.undelivered !== undefined ? bestIterationStats.undelivered : "N/A";
            
            const optDarkStoreDistancesEl = document.getElementById('optDarkStoreDistances');
            optDarkStoreDistancesEl.innerHTML = ""; 
            if (bestDarkStoreDistanceStats && bestDarkStoreDistanceStats.perStore && bestDarkStoreDistanceStats.perStore.length > 0) {
                const dsStat = bestDarkStoreDistanceStats.perStore[0]; 
                const li = document.createElement('li');
                if (dsStat) { 
                    li.textContent = `${dsStat.name}: Avg. Dist. ${dsStat.avgDist} km (${dsStat.orderCount} orders)`;
                    optDarkStoreDistancesEl.appendChild(li);
                }
                document.getElementById('optOverallAvgDistance').textContent = bestDarkStoreDistanceStats.overallAvg + " km";

                if(optimizationMapInstance) {
                    if(optDarkStoreMarkersLayer) optDarkStoreMarkersLayer.clearLayers();
                    if(optOrderMarkersLayer) optOrderMarkersLayer.clearLayers(); 
                    if (optOrderHeatmapLayer && optimizationMapInstance.hasLayer(optOrderHeatmapLayer)) { 
                        optimizationMapInstance.removeLayer(optOrderHeatmapLayer);
                        optOrderHeatmapLayer = null;
                    }

                    if (bestDarkStoreDistanceStats.locations && bestDarkStoreDistanceStats.locations.length > 0) {
                        const ds = bestDarkStoreDistanceStats.locations[0];
                         if(ds && typeof ds.lat === 'number' && typeof ds.lng === 'number') { 
                            L.marker([ds.lat, ds.lng], {icon: storeIconSim}).bindPopup(`${ds.name} (Optimal Scenario)`).addTo(optDarkStoreMarkersLayer);
                         }
                    }
                    
                    if (bestIterationOrderLocations.length > 0) {
                        bestIterationOrderLocations.forEach(orderLoc => {
                             if(orderLoc && typeof orderLoc.lat === 'number' && typeof orderLoc.lng === 'number') { 
                                L.circleMarker([orderLoc.lat, orderLoc.lng], {
                                    radius: 4, color: '#2563eb', fillColor: '#60a5fa', fillOpacity: 0.7, weight: 1
                                }).bindPopup(`Order Location (Optimal Scenario)<br>Lat: ${orderLoc.lat.toFixed(4)}, Lng: ${orderLoc.lng.toFixed(4)}`)
                                .addTo(optOrderMarkersLayer);
                             }
                        });
                    }
                }

            } else {
                 document.getElementById('optOverallAvgDistance').textContent = "N/A";
            }

            // Populate Comparison Table and Charts
            populateOptimizationComparisonTable(allOptimizationIterationsData);
            renderOptimizationCharts(allOptimizationIterationsData, targetAvgTime);
            comparisonTableContainer.classList.remove('hidden');
            chartsContainer.classList.remove('hidden');


            logMessageOpt(`Optimization complete. Best result found with ${bestAgentCount !== -1 ? bestAgentCount : 'N/A'} agents (Target: ${targetAvgTime} min).`, 'SYSTEM_BOLD', optLog);
            optLog.scrollTop = optLog.scrollHeight;
            runOptimizationButton.disabled = false;
            runOptimizationButton.textContent = "Run Workforce Optimization";
        }

        function populateOptimizationComparisonTable(iterationData) {
            const tableBody = document.getElementById('optimizationComparisonTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = ""; // Clear previous data

            iterationData.forEach(iter => {
                const row = tableBody.insertRow();
                row.insertCell().textContent = iter.agents;
                row.insertCell().textContent = iter.generatedOrders;
                row.insertCell().textContent = iter.deliveredOrders;
                row.insertCell().textContent = iter.avgDeliveryTime !== null ? iter.avgDeliveryTime.toFixed(1) : "N/A";
                row.insertCell().textContent = iter.minDeliveryTime !== null ? iter.minDeliveryTime.toFixed(1) : "N/A";
                row.insertCell().textContent = iter.maxDeliveryTime !== null ? iter.maxDeliveryTime.toFixed(1) : "N/A";
                row.insertCell().textContent = iter.stdDevDeliveryTime !== null ? iter.stdDevDeliveryTime.toFixed(1) : "N/A";
                row.insertCell().textContent = iter.avgAgentUtilization !== null ? iter.avgAgentUtilization.toFixed(1) + "%" : "N/A";
                row.insertCell().textContent = iter.avgOrderWaitTime !== null ? iter.avgOrderWaitTime.toFixed(1) : "N/A";
                row.insertCell().textContent = iter.undeliveredOrders;
            });
        }

        function renderOptimizationCharts(iterationData, targetTime) {
            const labels = iterationData.map(iter => iter.agents);
            const avgDeliveryTimes = iterationData.map(iter => iter.avgDeliveryTime);
            const avgUtilizations = iterationData.map(iter => iter.avgAgentUtilization);

            // Destroy previous charts if they exist
            if (deliveryTimeChartInstance) {
                deliveryTimeChartInstance.destroy();
            }
            if (utilizationChartInstance) {
                utilizationChartInstance.destroy();
            }

            // Delivery Time Chart
            const dtCtx = document.getElementById('deliveryTimeChart').getContext('2d');
            deliveryTimeChartInstance = new Chart(dtCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Avg. Delivery Time (min)',
                        data: avgDeliveryTimes,
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1,
                        fill: false
                    },
                    {
                        label: 'Target Avg. Delivery Time (min)',
                        data: Array(labels.length).fill(targetTime),
                        borderColor: 'rgb(255, 99, 132)',
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0 // No points for target line
                    }]
                },
                options: {
                    scales: { y: { beginAtZero: true, title: { display: true, text: 'Time (minutes)'} } , x: {title: {display: true, text: 'Number of Agents'}}}
                }
            });

            // Utilization Chart
            const utilCtx = document.getElementById('utilizationChart').getContext('2d');
            utilizationChartInstance = new Chart(utilCtx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Avg. Agent Utilization (%)',
                        data: avgUtilizations,
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgb(54, 162, 235)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: { y: { beginAtZero: true, max: 100, title: {display: true, text: 'Utilization (%)'} }, x:{title: {display: true, text: 'Number of Agents'}} }
                }
            });
        }


        // --- Demand Profile UI Logic ---
        let zoneCounter = 0;

        function initProfileCreationMap() {
            if (profileCreationMapInstance) return;
            profileCreationMapInstance = L.map('profileCreationMap').setView([chandigarhCenter.lat, chandigarhCenter.lng], 12);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(profileCreationMapInstance);
            L.polygon(chandigarhLeafletCoords, { color: '#334155', weight: 2, fill: false, dashArray: '5, 5', interactive: false }).addTo(profileCreationMapInstance);
            
            profileCreationMapInstance.on('click', function(e) {
                if (currentEditingZoneId) {
                    const latInput = document.getElementById(`zoneLat${currentEditingZoneId}`);
                    const lngInput = document.getElementById(`zoneLng${currentEditingZoneId}`);
                    const zoneTypeSelect = document.getElementById(`zoneType${currentEditingZoneId}`);

                    if (latInput && lngInput && zoneTypeSelect && zoneTypeSelect.value === 'hotspot') {
                        latInput.value = e.latlng.lat.toFixed(5);
                        lngInput.value = e.latlng.lng.toFixed(5);
                        updateProfileMapMarkers(); 
                    } else if (zoneTypeSelect && zoneTypeSelect.value === 'route') {
                        // Logic for adding points to a route
                        const routePointsInput = document.getElementById(`zoneRoutePoints${currentEditingZoneId}`);
                        currentRoutePoints.push([e.latlng.lat, e.latlng.lng]);
                        routePointsInput.value = JSON.stringify(currentRoutePoints);
                        updateProfileMapMarkers(); // Will draw the polyline
                    }
                }
            });
        }

        function addZoneToProfileForm() {
            zoneCounter++;
            const currentZoneId = zoneCounter; // Capture current counter for this zone
            const profileZonesContainer = document.getElementById('profileZonesContainer');
            const profileCreationMapContainer = document.getElementById('profileCreationMapContainer');
            profileCreationMapContainer.classList.remove('hidden'); 

            const zoneDiv = document.createElement('div');
            zoneDiv.className = 'profile-zone p-4 border rounded-md bg-slate-50';
            zoneDiv.setAttribute('data-zone-id', currentZoneId);
            zoneDiv.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <h5 class="font-semibold text-md text-slate-700">Zone ${currentZoneId}</h5>
                    <button type="button" class="btn btn-danger btn-sm remove-zone-btn" data-zone-id="${currentZoneId}">&times; Remove</button>
                </div>
                <div class="input-group">
                    <label for="zoneType${currentZoneId}">Zone Type:</label>
                    <select id="zoneType${currentZoneId}" class="zone-type-select w-full">
                        <option value="uniform">Uniform City-Wide</option>
                        <option value="hotspot" selected>Hotspot (Gaussian)</option>
                        <option value="sector">Sector-Based</option>
                        <option value="route">Route-Based (Experimental)</option>
                    </select>
                </div>
                <div class="grid grid-cols-2 gap-x-4">
                    <div class="input-group">
                        <label for="zoneMinOrders${currentZoneId}">Min Orders in Zone:</label>
                        <input type="number" id="zoneMinOrders${currentZoneId}" value="10" min="0" class="w-full">
                    </div>
                    <div class="input-group">
                        <label for="zoneMaxOrders${currentZoneId}">Max Orders in Zone:</label>
                        <input type="number" id="zoneMaxOrders${currentZoneId}" value="50" min="1" class="w-full">
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-x-4">
                    <div class="input-group">
                        <label for="zoneStartTime${currentZoneId}">Start Time (min):</label>
                        <input type="number" id="zoneStartTime${currentZoneId}" value="0" min="0" class="w-full">
                    </div>
                    <div class="input-group">
                        <label for="zoneEndTime${currentZoneId}">End Time (min):</label>
                        <input type="number" id="zoneEndTime${currentZoneId}" value="1440" min="0" class="w-full">
                    </div>
                </div>
                <div class="hotspot-fields"> 
                    <div class="input-group">
                        <label for="zoneLat${currentZoneId}">Hotspot Center Latitude:</label>
                        <input type="number" id="zoneLat${currentZoneId}" step="0.00001" placeholder="Click on map or enter" class="w-full hotspot-lat-input">
                    </div>
                    <div class="input-group">
                        <label for="zoneLng${currentZoneId}">Hotspot Center Longitude:</label>
                        <input type="number" id="zoneLng${currentZoneId}" step="0.00001" placeholder="Click on map or enter" class="w-full hotspot-lng-input">
                    </div>
                    <div class="input-group">
                        <label for="zoneSpread${currentZoneId}">Hotspot Spread/Radius (km):</label>
                        <input type="number" id="zoneSpread${currentZoneId}" value="1" min="0.1" step="0.1" class="w-full">
                    </div>
                </div>
                <div class="sector-fields hidden">
                    <div class="input-group">
                        <label for="zoneSectors${currentZoneId}">Select Sectors (Ctrl/Cmd + Click for multiple):</label>
                        <div class="sector-select-container p-2 border rounded-md bg-white">
                            ${chandigarhSectors.map(sector => `
                                <label class="block"><input type="checkbox" name="zoneSectors${currentZoneId}" value="${sector.name}"> ${sector.name}</label>
                            `).join('')}
                        </div>
                    </div>
                </div>
                <div class="route-fields hidden">
                     <div class="input-group">
                        <label for="zoneRoutePoints${currentZoneId}">Route Points (Lat,Lng pairs; click map to add):</label>
                        <textarea id="zoneRoutePoints${currentZoneId}" rows="3" class="w-full bg-slate-100" readonly placeholder="Click 'Start/Add to Route' then map..."></textarea>
                        <button type="button" class="btn btn-secondary btn-sm mt-1 start-add-route-btn" data-zone-id="${currentZoneId}">Start/Add to Route</button>
                        <button type="button" class="btn btn-danger btn-sm mt-1 clear-route-btn" data-zone-id="${currentZoneId}">Clear Route</button>
                    </div>
                    <div class="input-group">
                        <label for="zoneRouteSpread${currentZoneId}">Spread around Route (km):</label>
                        <input type="number" id="zoneRouteSpread${currentZoneId}" value="0.5" min="0.1" step="0.1" class="w-full">
                    </div>
                </div>
            `;
            profileZonesContainer.appendChild(zoneDiv);
            
            const zoneTypeSelect = zoneDiv.querySelector('.zone-type-select');
            const hotspotFieldsDiv = zoneDiv.querySelector('.hotspot-fields');
            const sectorFieldsDiv = zoneDiv.querySelector('.sector-fields');
            const routeFieldsDiv = zoneDiv.querySelector('.route-fields');
            
            function toggleZoneFields() {
                hotspotFieldsDiv.classList.toggle('hidden', zoneTypeSelect.value !== 'hotspot');
                sectorFieldsDiv.classList.toggle('hidden', zoneTypeSelect.value !== 'sector');
                routeFieldsDiv.classList.toggle('hidden', zoneTypeSelect.value !== 'route');
                currentEditingZoneId = (zoneTypeSelect.value === 'hotspot' || zoneTypeSelect.value === 'route') ? currentZoneId : null;
                if (zoneTypeSelect.value !== 'route') currentRoutePoints = [];
                updateProfileMapMarkers();
            }
            zoneTypeSelect.addEventListener('change', toggleZoneFields);
            toggleZoneFields(); 

            zoneDiv.querySelector('.remove-zone-btn').addEventListener('click', function() {
                zoneDiv.remove();
                updateProfileMapMarkers();
                if (profileZonesContainer.children.length === 0) {
                    profileCreationMapContainer.classList.add('hidden');
                }
            });
            zoneDiv.querySelectorAll('.hotspot-lat-input, .hotspot-lng-input, input[id^="zoneSpread"]').forEach(input => {
                input.addEventListener('input', () => { currentEditingZoneId = currentZoneId; updateProfileMapMarkers(); });
                input.addEventListener('focus', () => { currentEditingZoneId = currentZoneId; });
            });
            zoneDiv.querySelector('.start-add-route-btn').addEventListener('click', function() {
                 currentEditingZoneId = this.dataset.zoneId;
                 currentRoutePoints = []; 
                 const routePointsInput = document.getElementById(`zoneRoutePoints${currentEditingZoneId}`);
                 if(routePointsInput) routePointsInput.value = '';
                 logMessageSim(`[PROFILE] Started defining route for Zone ${currentEditingZoneId}. Click on the map.`, 'SYSTEM');
                 updateProfileMapMarkers();
            });
            zoneDiv.querySelector('.clear-route-btn').addEventListener('click', function() {
                currentEditingZoneId = this.dataset.zoneId;
                currentRoutePoints = [];
                const routePointsInput = document.getElementById(`zoneRoutePoints${currentEditingZoneId}`);
                if(routePointsInput) routePointsInput.value = '';
                updateProfileMapMarkers();
            });

            updateProfileMapMarkers(); 
        }

        function updateProfileMapMarkers() {
            if (!profileCreationMapInstance) return;
            tempZoneMarkers.forEach(marker => marker.remove());
            tempZoneMarkers = [];
            if (currentRoutePolylineLayer) {
                profileCreationMapInstance.removeLayer(currentRoutePolylineLayer);
                currentRoutePolylineLayer = null;
            }


            const zoneDivs = document.querySelectorAll('#profileZonesContainer .profile-zone');
            zoneDivs.forEach(zoneDiv => {
                const type = zoneDiv.querySelector('.zone-type-select').value;
                const zoneId = zoneDiv.dataset.zoneId;

                if (type === 'hotspot') {
                    const lat = parseFloat(zoneDiv.querySelector('.hotspot-lat-input').value);
                    const lng = parseFloat(zoneDiv.querySelector('.hotspot-lng-input').value);
                    const spreadKm = parseFloat(zoneDiv.querySelector('input[id^="zoneSpread"]').value);

                    if (!isNaN(lat) && !isNaN(lng) && !isNaN(spreadKm) && spreadKm > 0) {
                        const marker = L.marker([lat, lng]).addTo(profileCreationMapInstance)
                            .bindPopup(`Hotspot Center (Zone ${zoneId})<br>Spread: ${spreadKm} km`);
                        if (zoneId === currentEditingZoneId) marker.openPopup();
                        const circle = L.circle([lat, lng], {
                            radius: spreadKm * 1000, 
                            color: 'red', fillColor: '#f03', fillOpacity: 0.2
                        }).addTo(profileCreationMapInstance);
                        tempZoneMarkers.push(marker, circle);
                    }
                } else if (type === 'route' && zoneId === currentEditingZoneId && currentRoutePoints.length > 0) {
                     currentRoutePoints.forEach(p => {
                        const pointMarker = L.circleMarker(p, {radius: 5, color: 'blue'}).addTo(profileCreationMapInstance);
                        tempZoneMarkers.push(pointMarker);
                     });
                    if (currentRoutePoints.length > 1) {
                        currentRoutePolylineLayer = L.polyline(currentRoutePoints, {color: 'blue', weight: 3}).addTo(profileCreationMapInstance);
                        tempZoneMarkers.push(currentRoutePolylineLayer); // Add to temp so it can be cleared
                    }
                }
            });
        }


        function saveCustomDemandProfile() {
            const profileNameInput = document.getElementById('profileNameInput');
            const profileName = profileNameInput.value.trim();
            if (!profileName) {
                alert("Please enter a name for the profile.");
                return;
            }
            
            const existingProfileIndex = customDemandProfiles.findIndex(p => p.name === profileName);
            if (existingProfileIndex !== -1) {
                if (!confirm(`A profile named "${profileName}" already exists. Overwrite it?`)) {
                    return;
                }
                customDemandProfiles.splice(existingProfileIndex, 1); // Remove existing to overwrite
            }

            const zones = [];
            const zoneDivs = document.querySelectorAll('#profileZonesContainer .profile-zone');
            if (zoneDivs.length === 0) {
                alert("Please add at least one zone to the profile.");
                return;
            }

            let profileIsValid = true;
            zoneDivs.forEach(zoneDiv => {
                const type = zoneDiv.querySelector('.zone-type-select').value;
                const minOrders = parseInt(zoneDiv.querySelector('input[id^="zoneMinOrders"]').value) || 0;
                const maxOrders = parseInt(zoneDiv.querySelector('input[id^="zoneMaxOrders"]').value) || 0;
                const startTime = parseInt(zoneDiv.querySelector('input[id^="zoneStartTime"]').value) || 0;
                const endTime = parseInt(zoneDiv.querySelector('input[id^="zoneEndTime"]').value) || Infinity;

                if (minOrders > maxOrders) {
                    alert(`Min Orders cannot be greater than Max Orders for a zone in profile "${profileName}".`);
                    profileIsValid = false; return;
                }
                if (startTime > endTime) {
                     alert(`Start Time cannot be greater than End Time for a zone in profile "${profileName}".`);
                    profileIsValid = false; return;
                }
                
                if (type === 'uniform') {
                    zones.push({ type: 'uniform', minOrders, maxOrders, startTime, endTime });
                } else if (type === 'hotspot') {
                    const centerLat = parseFloat(zoneDiv.querySelector('.hotspot-lat-input').value);
                    const centerLng = parseFloat(zoneDiv.querySelector('.hotspot-lng-input').value);
                    const spreadKm = parseFloat(zoneDiv.querySelector('input[id^="zoneSpread"]').value) || 1;
                    if (isNaN(centerLat) || isNaN(centerLng)) {
                        alert(`Invalid latitude or longitude for a hotspot zone in profile "${profileName}".`);
                        profileIsValid = false; return;
                    }
                    zones.push({ type: 'hotspot', minOrders, maxOrders, startTime, endTime, centerLat, centerLng, spreadKm });
                } else if (type === 'sector') {
                    const selectedSectorCheckboxes = zoneDiv.querySelectorAll('input[name^="zoneSectors"]:checked');
                    const selectedSectors = Array.from(selectedSectorCheckboxes).map(cb => cb.value);
                    if (selectedSectors.length === 0) {
                        alert(`Please select at least one sector for the sector-based zone in profile "${profileName}".`);
                        profileIsValid = false; return;
                    }
                    zones.push({ type: 'sector', minOrders, maxOrders, startTime, endTime, selectedSectors });
                } else if (type === 'route') {
                    const routePointsText = zoneDiv.querySelector('textarea[id^="zoneRoutePoints"]').value;
                    let routePoints = [];
                    try {
                        routePoints = JSON.parse(routePointsText || "[]");
                        if (!Array.isArray(routePoints) || !routePoints.every(p => Array.isArray(p) && p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number')) {
                            throw new Error("Invalid route points format.");
                        }
                    } catch (e) {
                         alert(`Invalid route points for a route-based zone in profile "${profileName}". Please define the route on the map.`);
                         profileIsValid = false; return;
                    }
                    if (routePoints.length < 2) { // A route needs at least two points
                         alert(`A route-based zone requires at least 2 points. Profile: "${profileName}".`);
                         profileIsValid = false; return;
                    }
                    const routeSpreadKm = parseFloat(zoneDiv.querySelector('input[id^="zoneRouteSpread"]').value) || 0.5;
                    zones.push({ type: 'route', minOrders, maxOrders, startTime, endTime, routePoints, routeSpreadKm });
                }
            });

            if (!profileIsValid) return; // Stop if any zone was invalid

            customDemandProfiles.push({ name: profileName, zones: zones });
            logMessageSim(`Custom demand profile "${profileName}" saved with ${zones.length} zone(s).`, 'SYSTEM');
            updateSavedProfilesList();
            populateOrderGenerationProfileSelector(); 
            clearProfileForm();
        }
        
        function clearProfileForm() {
            document.getElementById('profileNameInput').value = '';
            document.getElementById('profileZonesContainer').innerHTML = '';
            zoneCounter = 0; // Reset counter for new zones
            currentEditingZoneId = null;
            currentRoutePoints = [];
            if (profileCreationMapInstance) {
                 tempZoneMarkers.forEach(marker => marker.remove());
                 tempZoneMarkers = [];
                 if(currentRoutePolylineLayer) profileCreationMapInstance.removeLayer(currentRoutePolylineLayer);
                 currentRoutePolylineLayer = null;
            }
            document.getElementById('profileCreationMapContainer').classList.add('hidden');
        }

        function updateSavedProfilesList() {
            const listEl = document.getElementById('savedProfilesList');
            listEl.innerHTML = '';
            if (customDemandProfiles.length === 0) {
                listEl.innerHTML = '<li class="italic text-slate-500">No custom profiles saved yet.</li>';
                return;
            }
            customDemandProfiles.forEach((profile, index) => {
                const li = document.createElement('li');
                li.className = "flex justify-between items-center py-1";
                
                const profileText = document.createElement('span');
                profileText.textContent = `${profile.name} (${profile.zones.length} zones)`;
                profileText.className = "cursor-pointer hover:text-blue-600";
                profileText.onclick = () => loadProfileForEditing(profile.name);
                li.appendChild(profileText);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.className = 'btn btn-danger btn-sm text-xs';
                deleteBtn.onclick = () => deleteCustomProfile(profile.name);
                li.appendChild(deleteBtn);

                listEl.appendChild(li);
            });
        }

        function loadProfileForEditing(profileName) {
            const profile = customDemandProfiles.find(p => p.name === profileName);
            if (!profile) return;

            clearProfileForm(); // Clear existing form
            document.getElementById('profileNameInput').value = profile.name;
            const profileZonesContainer = document.getElementById('profileZonesContainer');
            const profileCreationMapContainer = document.getElementById('profileCreationMapContainer');


            profile.zones.forEach(zoneData => {
                zoneCounter++; // Increment for unique IDs
                const currentZoneId = zoneCounter;
                const zoneDiv = document.createElement('div');
                zoneDiv.className = 'profile-zone p-4 border rounded-md bg-slate-50';
                zoneDiv.setAttribute('data-zone-id', currentZoneId);

                let zoneSpecificHTML = '';
                if (zoneData.type === 'hotspot') {
                    zoneSpecificHTML = `
                        <div class="hotspot-fields">
                            <div class="input-group">
                                <label for="zoneLat${currentZoneId}">Hotspot Center Latitude:</label>
                                <input type="number" id="zoneLat${currentZoneId}" value="${zoneData.centerLat}" step="0.00001" class="w-full hotspot-lat-input">
                            </div>
                            <div class="input-group">
                                <label for="zoneLng${currentZoneId}">Hotspot Center Longitude:</label>
                                <input type="number" id="zoneLng${currentZoneId}" value="${zoneData.centerLng}" step="0.00001" class="w-full hotspot-lng-input">
                            </div>
                            <div class="input-group">
                                <label for="zoneSpread${currentZoneId}">Hotspot Spread/Radius (km):</label>
                                <input type="number" id="zoneSpread${currentZoneId}" value="${zoneData.spreadKm}" min="0.1" step="0.1" class="w-full">
                            </div>
                        </div>
                        <div class="sector-fields hidden">...</div> <div class="route-fields hidden">...</div>`;
                } else if (zoneData.type === 'uniform') {
                     zoneSpecificHTML = `<div class="hotspot-fields hidden">...</div> <div class="sector-fields hidden">...</div> <div class="route-fields hidden">...</div>`;
                } else if (zoneData.type === 'sector') {
                    zoneSpecificHTML = `
                        <div class="hotspot-fields hidden">...</div>
                        <div class="sector-fields">
                            <div class="input-group">
                                <label for="zoneSectors${currentZoneId}">Select Sectors (Ctrl/Cmd + Click for multiple):</label>
                                <div class="sector-select-container p-2 border rounded-md bg-white">
                                    ${chandigarhSectors.map(sector => `
                                        <label class="block"><input type="checkbox" name="zoneSectors${currentZoneId}" value="${sector.name}" ${zoneData.selectedSectors.includes(sector.name) ? 'checked' : ''}> ${sector.name}</label>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                        <div class="route-fields hidden">...</div>`;
                } else if (zoneData.type === 'route') {
                     zoneSpecificHTML = `
                        <div class="hotspot-fields hidden">...</div>
                        <div class="sector-fields hidden">...</div>
                        <div class="route-fields">
                            <div class="input-group">
                                <label for="zoneRoutePoints${currentZoneId}">Route Points (Lat,Lng pairs; click map to add):</label>
                                <textarea id="zoneRoutePoints${currentZoneId}" rows="3" class="w-full bg-slate-100" readonly>${JSON.stringify(zoneData.routePoints || [])}</textarea>
                                <button type="button" class="btn btn-secondary btn-sm mt-1 start-add-route-btn" data-zone-id="${currentZoneId}">Start/Add to Route</button>
                                <button type="button" class="btn btn-danger btn-sm mt-1 clear-route-btn" data-zone-id="${currentZoneId}">Clear Route</button>
                            </div>
                            <div class="input-group">
                                <label for="zoneRouteSpread${currentZoneId}">Spread around Route (km):</label>
                                <input type="number" id="zoneRouteSpread${currentZoneId}" value="${zoneData.routeSpreadKm || 0.5}" min="0.1" step="0.1" class="w-full">
                            </div>
                        </div>`;
                }


                zoneDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <h5 class="font-semibold text-md text-slate-700">Zone ${currentZoneId}</h5>
                        <button type="button" class="btn btn-danger btn-sm remove-zone-btn" data-zone-id="${currentZoneId}">&times; Remove</button>
                    </div>
                    <div class="input-group">
                        <label for="zoneType${currentZoneId}">Zone Type:</label>
                        <select id="zoneType${currentZoneId}" class="zone-type-select w-full">
                            <option value="uniform" ${zoneData.type === 'uniform' ? 'selected' : ''}>Uniform City-Wide</option>
                            <option value="hotspot" ${zoneData.type === 'hotspot' ? 'selected' : ''}>Hotspot (Gaussian)</option>
                            <option value="sector" ${zoneData.type === 'sector' ? 'selected' : ''}>Sector-Based</option>
                            <option value="route" ${zoneData.type === 'route' ? 'selected' : ''}>Route-Based (Experimental)</option>
                        </select>
                    </div>
                     <div class="grid grid-cols-2 gap-x-4">
                        <div class="input-group">
                            <label for="zoneMinOrders${currentZoneId}">Min Orders in Zone:</label>
                            <input type="number" id="zoneMinOrders${currentZoneId}" value="${zoneData.minOrders || 0}" min="0" class="w-full">
                        </div>
                        <div class="input-group">
                            <label for="zoneMaxOrders${currentZoneId}">Max Orders in Zone:</label>
                            <input type="number" id="zoneMaxOrders${currentZoneId}" value="${zoneData.maxOrders || 1}" min="1" class="w-full">
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-x-4">
                        <div class="input-group">
                            <label for="zoneStartTime${currentZoneId}">Start Time (min):</label>
                            <input type="number" id="zoneStartTime${currentZoneId}" value="${zoneData.startTime || 0}" min="0" class="w-full">
                        </div>
                        <div class="input-group">
                            <label for="zoneEndTime${currentZoneId}">End Time (min):</label>
                            <input type="number" id="zoneEndTime${currentZoneId}" value="${zoneData.endTime === Infinity ? 1440 : zoneData.endTime}" min="0" class="w-full">
                        </div>
                    </div>
                    ${zoneSpecificHTML}
                `;
                profileZonesContainer.appendChild(zoneDiv);

                const zoneTypeSelect = zoneDiv.querySelector('.zone-type-select');
                const hotspotFieldsDiv = zoneDiv.querySelector('.hotspot-fields');
                const sectorFieldsDiv = zoneDiv.querySelector('.sector-fields');
                const routeFieldsDiv = zoneDiv.querySelector('.route-fields');

                function toggleZoneFields() {
                    hotspotFieldsDiv.classList.toggle('hidden', zoneTypeSelect.value !== 'hotspot');
                    sectorFieldsDiv.classList.toggle('hidden', zoneTypeSelect.value !== 'sector');
                    routeFieldsDiv.classList.toggle('hidden', zoneTypeSelect.value !== 'route');
                    currentEditingZoneId = (zoneTypeSelect.value === 'hotspot' || zoneTypeSelect.value === 'route') ? currentZoneId : null;
                    if (zoneTypeSelect.value !== 'route') currentRoutePoints = [];
                    else if (zoneTypeSelect.value === 'route' && zoneData.routePoints) currentRoutePoints = [...zoneData.routePoints]; // Load existing route points
                    updateProfileMapMarkers();
                }
                zoneTypeSelect.addEventListener('change', toggleZoneFields);
                toggleZoneFields(); 

                zoneDiv.querySelector('.remove-zone-btn').addEventListener('click', function() {
                    zoneDiv.remove();
                    updateProfileMapMarkers();
                     if (profileZonesContainer.children.length === 0) {
                        profileCreationMapContainer.classList.add('hidden');
                    }
                });
                 zoneDiv.querySelectorAll('.hotspot-lat-input, .hotspot-lng-input, input[id^="zoneSpread"]').forEach(input => {
                    input.addEventListener('input', () => { currentEditingZoneId = currentZoneId; updateProfileMapMarkers(); });
                    input.addEventListener('focus', () => { currentEditingZoneId = currentZoneId; });
                });
                zoneDiv.querySelector('.start-add-route-btn')?.addEventListener('click', function() {
                     currentEditingZoneId = this.dataset.zoneId;
                     currentRoutePoints = []; 
                     const routePointsInput = document.getElementById(`zoneRoutePoints${currentEditingZoneId}`);
                     if(routePointsInput) routePointsInput.value = '';
                     logMessageSim(`[PROFILE] Started defining route for Zone ${currentEditingZoneId}. Click on the map.`, 'SYSTEM');
                     updateProfileMapMarkers();
                });
                zoneDiv.querySelector('.clear-route-btn')?.addEventListener('click', function() {
                    currentEditingZoneId = this.dataset.zoneId;
                    currentRoutePoints = [];
                    const routePointsInput = document.getElementById(`zoneRoutePoints${currentEditingZoneId}`);
                    if(routePointsInput) routePointsInput.value = '';
                    updateProfileMapMarkers();
                });
            });
            profileCreationMapContainer.classList.remove('hidden');
            updateProfileMapMarkers();
        }

        function deleteCustomProfile(profileName) {
            if (confirm(`Are you sure you want to delete the profile "${profileName}"?`)) {
                customDemandProfiles = customDemandProfiles.filter(p => p.name !== profileName);
                updateSavedProfilesList();
                populateOrderGenerationProfileSelector(); // Update dropdown on simulation page
                logMessageSim(`Custom demand profile "${profileName}" deleted.`, 'SYSTEM');
            }
        }
        
        function populateOrderGenerationProfileSelector() {
            const selector = document.getElementById('orderGenerationProfileSelect');
            if (!selector) return;

            const currentValue = selector.value; // Preserve current selection if possible
            const defaultOptions = Array.from(selector.options).filter(opt => opt.value.startsWith('default_'));
            selector.innerHTML = '';
            defaultOptions.forEach(opt => selector.appendChild(opt));

            customDemandProfiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = `custom_${profile.name}`;
                option.textContent = `Custom: ${profile.name}`;
                selector.appendChild(option);
            });
            // Try to reselect previous value
            if (Array.from(selector.options).some(opt => opt.value === currentValue)) {
                selector.value = currentValue;
            } else {
                 selector.value = 'default_uniform'; // Fallback
            }
            // Trigger change event to update UI visibility for default sliders
             const event = new Event('change');
             selector.dispatchEvent(event);
        }


    </script>
</body>
</html>
